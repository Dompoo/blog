## 1. 쿠폰의 발급 수량 조회 성능 분석 및 성능 향상 (IndexPerformanceTest)

```java
@Test
void 쿠폰의_발급_수량_조회() throws InterruptedException {
    AtomicBoolean running = new AtomicBoolean(false);
    AtomicInteger requestCount = new AtomicInteger(0);
    AtomicLong totalElapsedTime = new AtomicLong(0);

    int statusCode = RestAssured.get("/coupons/" + ThreadLocalRandom.current()
                    .nextLong(MIN_COUPON_ID, MAX_COUPON_ID + 1) + "/issued-count").statusCode();
    assertThat(statusCode).withFailMessage("쿠폰의 발급 수량 조회 API 호출에 실패했습니다. 테스트 대상 서버가 실행중인지 확인해 주세요.").isEqualTo(200);

    executeMultipleRequests(running, requestCount, totalElapsedTime,
            () -> RestAssured.get("/coupons/" + ThreadLocalRandom.current()
                    .nextLong(MIN_COUPON_ID, MAX_COUPON_ID + 1) + "/issued-count"));

    System.out.println("Total request count: " + requestCount.get());
    System.out.println("Total elapsed time: " + totalElapsedTime.get() + "ms");

    long averageElapsedTime = totalElapsedTime.get() / requestCount.get();
    System.out.println("Average elapsed time: " + averageElapsedTime + "ms");

    assertThat(averageElapsedTime).isLessThanOrEqualTo(100L);
}

// CouponController
@GetMapping("{couponId:^\\\\d+$}/issued-count")
public Long getCouponIssuedCount(@PathVariable("couponId") Long couponId) {
    Coupon coupon = couponService.getCoupon(couponId);
    return memberCouponService.findIssuedCouponCount(coupon.getId());
}

// CouponService
@Transactional(readOnly = true)
public Coupon getCoupon(Long couponId) {
    return couponRepository.findById(couponId)
            .orElseThrow(() -> new IllegalArgumentException("존재하지 않는 쿠폰입니다. couponId: " + couponId));
}

// MemberCouponService
@Transactional(readOnly = true)
public Long findIssuedCouponCount(Long couponId) {
    return memberCouponRepository.countByCoupon_Id(couponId);
}

/* <criteria> */ select
        count(mc1_0.id) 
    from
        member_coupon mc1_0 
    left join
        coupon c1_0 
            on c1_0.id=mc1_0.coupon_id 
    where
        c1_0.id=?
```

1. couponRepository에서 couponId로 조회
2. 해당 couponId로 memberCouponRepository에서 집계

### 문제

![스크린샷 2025-10-12 17.39.12.png](attachment:4bd1a67e-1a44-4fce-8d9a-6dd9df521fb2:%E1%84%89%E1%85%B3%E1%84%8F%E1%85%B3%E1%84%85%E1%85%B5%E1%86%AB%E1%84%89%E1%85%A3%E1%86%BA_2025-10-12_17.39.12.png)

목표는 **Average elapsed time을 100ms**로 줄이는 것이다.

coupon에서는 id가 기본 키이므로 이미 **인덱스 존재**

member_coupon에서는 used, coupon_id가 복합 인덱스로 설정되어 **coupon_id에 대한 인덱스 미존재**

→ used 기준으로 먼저 정렬하고, coupon_id로 정렬하기 때문에 used 없으면 coupon_id 단독 사용이 불가

**EXPLAIN 결과**

![스크린샷 2025-10-12 17.16.30.png](attachment:22f7e052-1e0a-42bc-8cbc-3290209831c3:%E1%84%89%E1%85%B3%E1%84%8F%E1%85%B3%E1%84%85%E1%85%B5%E1%86%AB%E1%84%89%E1%85%A3%E1%86%BA_2025-10-12_17.16.30.png)

c1_0(coupon) 테이블의 경우에는 PRIMARY KEY로 조회하기 때문에 rows가 1인 것을 확인 가능

그러나, mc1_0(member_coupon)은 index를 사용하지만, 495818개의 rows를 탐색했다.

type: index는 인덱스 풀 스캔(전체 인덱스를 처음부터 끝까지 읽음)

possible_key: NULL은 사용할 인덱스를 찾지 못했다는 뜻

key: idx_coupon_id로 일단 선택했다.

ref: NULL 인덱스를 검색 조건으로 쓰지않고 스캔만 했다.

### 해결 방법

1. coupon_id에 대한 인덱스를 생성한다.
2. (used, coupon_id)로 만들어져 있는 인덱스를 (coupon_id, used)로 변경한다. ✅

```sql
ALTER TABLE member_coupon DROP INDEX idx_coupon_id;
ALTER TABLE member_coupon ADD INDEX idx_coupon_id (coupon_id, used);
```

**이유**

- 인덱스는 작게 만들수록 좋다. (insert, update 성능 떨어짐)
- 각각 B-Tree를 만들기에 저장 공간을 차지한다.
- 지금 당장 used를 사용하지 않는다.
    - 추후에 사용하면 used 추가하면 될듯?

### 결과

![스크린샷 2025-10-12 17.37.23.png](attachment:6c0175a2-3d49-4d82-ba8a-c1c8b329d5ba:%E1%84%89%E1%85%B3%E1%84%8F%E1%85%B3%E1%84%85%E1%85%B5%E1%86%AB%E1%84%89%E1%85%A3%E1%86%BA_2025-10-12_17.37.23.png)

![스크린샷 2025-10-12 17.36.18.png](attachment:75d38b81-fae5-4cb6-b422-fd27219208f6:%E1%84%89%E1%85%B3%E1%84%8F%E1%85%B3%E1%84%85%E1%85%B5%E1%86%AB%E1%84%89%E1%85%A3%E1%86%BA_2025-10-12_17.36.18.png)

**Average elapsed time 286ms → 9ms 개선**

## 2. 쿠폰의 사용 수량 조회 성능 분석 및 성능 향상 (IndexPerformanceTest)

```java
@Test
void 쿠폰의_사용_수량_조회() throws InterruptedException {
    AtomicBoolean running = new AtomicBoolean(false);
    AtomicInteger requestCount = new AtomicInteger(0);
    AtomicLong totalElapsedTime = new AtomicLong(0);

    int statusCode = RestAssured.get("/coupons/" + ThreadLocalRandom.current()
                    .nextLong(MIN_COUPON_ID, MAX_COUPON_ID + 1) + "/used-count").statusCode();
    assertThat(statusCode).withFailMessage("쿠폰의 사용 수량 조회 API 호출에 실패했습니다. 테스트 대상 서버가 실행중인지 확인해 주세요.").isEqualTo(200);

    executeMultipleRequests(running, requestCount, totalElapsedTime,
            () -> RestAssured.get("/coupons/" + ThreadLocalRandom.current()
                    .nextLong(MIN_COUPON_ID, MAX_COUPON_ID + 1) + "/used-count"));

    System.out.println("Total request count: " + requestCount.get());
    System.out.println("Total elapsed time: " + totalElapsedTime.get() + "ms");

    long averageElapsedTime = totalElapsedTime.get() / requestCount.get();
    System.out.println("Average elapsed time: " + totalElapsedTime.get() / requestCount.get() + "ms");

    assertThat(averageElapsedTime).isLessThanOrEqualTo(100L);
}

// CouponController
@GetMapping("{couponId:^\\\\d+$}/used-count")
public Long getCouponUsedCount(@PathVariable("couponId") Long couponId) {
    Coupon coupon = couponService.getCoupon(couponId);
    return memberCouponService.findUsedCouponCount(coupon.getId());
}

// CouponService
@Transactional(readOnly = true)
public Coupon getCoupon(Long couponId) {
    return couponRepository.findById(couponId)
            .orElseThrow(() -> new IllegalArgumentException("존재하지 않는 쿠폰입니다. couponId: " + couponId));
}

// MemberCouponService
@Transactional(readOnly = true)
public Long findUsedCouponCount(Long couponId) {
    return memberCouponRepository.countByCoupon_IdAndUsed(couponId, true);
}
```

### 문제 (1번과 함께 해결됨)

![스크린샷 2025-10-12 17.41.53.png](attachment:776cb7b0-8bd8-411e-baf8-df859d801ac3:%E1%84%89%E1%85%B3%E1%84%8F%E1%85%B3%E1%84%85%E1%85%B5%E1%86%AB%E1%84%89%E1%85%A3%E1%86%BA_2025-10-12_17.41.53.png)

목표는 **Average elapsed time을 100ms**로 줄이는 것이다.

![스크린샷 2025-10-12 17.47.59.png](attachment:5d5e738f-5c03-45eb-99d2-2c8485077502:%E1%84%89%E1%85%B3%E1%84%8F%E1%85%B3%E1%84%85%E1%85%B5%E1%86%AB%E1%84%89%E1%85%A3%E1%86%BA_2025-10-12_17.47.59.png)

1번 문제를 해결하면서 `idx_coupon_id(coupon_id, used)` 로 인덱스를 바꿨다. 근데 해당 로직을 위한 MemberCouponService를 보면 `countByCoupon_idAndUsed()` 호출로 바꾼 인덱스를 활용하는 모습을 볼 수 있다.

## 3. 현재 발급 가능한 쿠폰 조회 성능 분석 및 성능 향상 (IndexPerformanceTest)

```java
@Test
void 현재_발급_가능한_쿠폰_조회() throws InterruptedException {
    AtomicBoolean running = new AtomicBoolean(false);
    AtomicInteger requestCount = new AtomicInteger(0);
    AtomicLong totalElapsedTime = new AtomicLong(0);

    int statusCode = RestAssured.get("/coupons/issuable").statusCode();
    assertThat(statusCode).withFailMessage("발급 가능한 쿠폰 조회 API 호출에 실패했습니다. 테스트 대상 서버가 실행중인지 확인해 주세요.").isEqualTo(200);

    executeMultipleRequests(running, requestCount, totalElapsedTime, () -> RestAssured.get("/coupons/issuable"));

    System.out.println("Total request count: " + requestCount.get());
    System.out.println("Total elapsed time: " + totalElapsedTime.get() + "ms");

    long averageElapsedTime = totalElapsedTime.get() / requestCount.get();
    System.out.println("Average elapsed time: " + totalElapsedTime.get() / requestCount.get() + "ms");

    assertThat(averageElapsedTime).isLessThanOrEqualTo(500L);
}

// CouponController
@GetMapping("/issuable")
public List<CouponResponse> findIssuableCoupons() {
    return couponService.findIssuableCoupons().stream()
            .map(CouponResponse::from)
            .collect(toList());
}

// CouponService
public List<Coupon> findIssuableCoupons() {
    LocalDateTime now = LocalDateTime.now();
    return couponRepository.findAllByIssuableAndCouponStatusAndIssueStartedAtLessThanAndIssueEndedAtGreaterThan(
                    true, CouponStatus.ISSUABLE, now, now).stream()
            .filter(coupon -> coupon.isIssuableCoupon(now))
            .collect(toList());
}
```

### 문제

![스크린샷 2025-10-12 17.51.03.png](attachment:cd5b3ca8-8db6-4e83-9e82-98fc68f656ac:%E1%84%89%E1%85%B3%E1%84%8F%E1%85%B3%E1%84%85%E1%85%B5%E1%86%AB%E1%84%89%E1%85%A3%E1%86%BA_2025-10-12_17.51.03.png)

목표는 **Average elapsed time을 500ms**로 줄이는 것이다.

**EXPLAIN 결과**

![스크린샷 2025-10-14 오후 3.05.48.png](attachment:d534b39d-9b45-4501-8d7c-595ef8a09e0e:%E1%84%89%E1%85%B3%E1%84%8F%E1%85%B3%E1%84%85%E1%85%B5%E1%86%AB%E1%84%89%E1%85%A3%E1%86%BA_2025-10-14_%E1%84%8B%E1%85%A9%E1%84%92%E1%85%AE_3.05.48.png)

**기존 인덱스**

```sql
create index mouda_goat3 on coupon (coupon_status);
```

EXPLAIN 결과를 보면 `mouda_goat3` 라는 인덱스를 활용하고 있지만, 약 17만개의 rows를 읽을 것이라 예측하고 있다. 날짜로 범위 검색을 하고 있는데, 해당 조건에 대한 인덱스가 없어서 많은 rows를 읽을 것이라 예측한 것 같다. 그래서 먼저 where 조건 속 모든 컬럼에 인덱스를 걸었다.

### **모든 컬럼 복합 인덱스** EXPLAIN

```sql
CREATE INDEX idx_coupon_issue_search ON coupon(
    coupon_status,
    issue_started_at,
    issue_ended_at,
    issuable
);
```

![스크린샷 2025-10-12 19.55.48.png](attachment:b203cbed-0369-4cc3-8fb8-b31f369ab5cd:%E1%84%89%E1%85%B3%E1%84%8F%E1%85%B3%E1%84%85%E1%85%B5%E1%86%AB%E1%84%89%E1%85%A3%E1%86%BA_2025-10-12_19.55.48.png)

지금처럼 (coupon_status, issue_started_at, issue_ended_at, issuable)으로 인덱스를 만든 것보다 where 조건 순서대로 인덱스를 만드는 것이 오히려 예측한 rows가 많았다.

### 결과

그 어떤 인덱스도 기존의 인덱스보다 성능 개선이 이뤄지지 않는다. 그러면 굳이 저장 공간을 차지하고, 삽입 성능을 낮추는 다른 인덱스를 걸 필요는 없다.

## 4. 회원이 가지고 있는 사용 가능한 쿠폰 조회 성능 분석 및 성능 향상 (IndexPerformanceTest)

```java
@Test
void 회원이_가지고_있는_사용_가능한_쿠폰_조회() throws InterruptedException {
    AtomicBoolean running = new AtomicBoolean(false);
    AtomicInteger requestCount = new AtomicInteger(0);
    AtomicLong totalElapsedTime = new AtomicLong(0);

    int statusCode = RestAssured.get("/member-coupons/by-member-id?memberId=" + ThreadLocalRandom.current()
            .nextLong(MIN_MEMBER_ID, MAX_MEMBER_ID + 1)).statusCode();
    assertThat(statusCode).withFailMessage("회원이 가지고 있는 쿠폰 조회 API 호출에 실패했습니다. 테스트 대상 서버가 실행중인지 확인해 주세요.").isEqualTo(200);

    executeMultipleRequests(running, requestCount, totalElapsedTime,
            () -> RestAssured.get("/member-coupons/by-member-id?memberId=" + ThreadLocalRandom.current()
                    .nextLong(MIN_MEMBER_ID, MAX_MEMBER_ID + 1)));

    System.out.println("Total request count: " + requestCount.get());
    System.out.println("Total elapsed time: " + totalElapsedTime.get() + "ms");

    long averageElapsedTime = totalElapsedTime.get() / requestCount.get();
    System.out.println("Average elapsed time: " + totalElapsedTime.get() / requestCount.get() + "ms");

    assertThat(averageElapsedTime).isLessThanOrEqualTo(100L);
}

// MemberCouponController
@GetMapping("/by-member-id")
public List<MemberCouponResponse> getMemberCoupons(@RequestParam("memberId") Long memberId) {
    return memberCouponService.findUsableMemberCoupons(memberId).stream()
            .map(MemberCouponResponse::from)
            .collect(toList());
}

// MemberCouponService
@Transactional(readOnly = true)
public List<MemberCoupon> findUsableMemberCoupons(Long memberId) {
    return memberCouponRepository.findByMemberIdAndUsedAndUseEndedAtAfter(memberId, false, LocalDateTime.now())
            .stream()
            .filter(memberCoupon -> memberCoupon.getCoupon().isUsableCoupon())
            .collect(toList());
}
```

### 문제

![image.png](attachment:e3c788a7-5fe1-4f0b-a56e-6cd82fc9ae8c:image.png)

![스크린샷 2025-10-12 20.12.26.png](attachment:358b5834-bdfc-440b-961f-c57b76e3c74c:%E1%84%89%E1%85%B3%E1%84%8F%E1%85%B3%E1%84%85%E1%85%B5%E1%86%AB%E1%84%89%E1%85%A3%E1%86%BA_2025-10-12_20.12.26.png)

목표는 **Average elapsed time을 100ms**로 줄이는 것이다.

**EXPLAIN 결과**

![스크린샷 2025-10-12 20.18.19.png](attachment:2ed0b6ed-a3a8-41bc-8bf7-324d455a0418:%E1%84%89%E1%85%B3%E1%84%8F%E1%85%B3%E1%84%85%E1%85%B5%E1%86%AB%E1%84%89%E1%85%A3%E1%86%BA_2025-10-12_20.18.19.png)

결과를 보면 어떤 인덱스도 활용하고 있지 않아서 모든 컬럼을 조회하고 있다는 사실을 알 수 있다. 어떤 인덱스를 추가해야 할까?

일단 조회에 사용되는 조건을 보면 member_id, used, use_ended_at이 있다. 이들 모두를 일단 인덱스를 걸어보았다.

### 모든 조건 컬럼 인덱스

EXPLAIN과 실행 결과를 보면 단 한건의 rows만 검사하고 바로 읽어온 것을 볼 수 있다. 인덱스로 인해 엄청난 성능이 개선된 것이다. 하지만, 인덱스 컬럼 중 use_ended_at은 정말 범용적일까? 이를 위해 MemberCouponRepository를 확인해봤다.

```sql
@Repository
@Transactional
public interface MemberCouponRepository extends JpaRepository<MemberCoupon, Long> {
    List<MemberCoupon> findByMemberIdAndUsedAndUseEndedAtAfter(Long memberId, boolean used, LocalDateTime now);

    Long countByCoupon_Id(Long couponId);

    Long countByCoupon_IdAndUsed(Long couponId, boolean used);

    @Modifying
    @Query("update MemberCoupon mc set mc.used = :used, mc.usedAt = :usedAt where mc.id in :memberCouponIds")
    void updateUsedAndUsedAt(@Param("memberCouponIds") List<Long> memberCouponIds, @Param("used") boolean used,
                             @Param("usedAt") LocalDateTime usedAt);
}
```

보면 member_id, used, now를 조건으로 하는 쿼리는 하나 밖에 없다. 이런식으로 결정해도 될지는 모르겠으나 member_id, used만 사용하는 인덱스를 만드는게 더 좋을 것 같다. 이유는 member_id, used는 다른 방식으로도 활용될 수 있는 인덱스지만 use_ended_at은 정말 인덱스에 필요한 컬럼일까? 해당 쿼리에만 제한되는 것 같다. 예를 들어 현재 테스트와 반대로 회원이 사용할 수 없는 쿠폰 개수를 조회한다고 하자. 그럼 기존 member_id, used는 그대로 사용될 수 있지만, use_ended_at은 사용되지 않을 가능성이 크다.

이런 경우에는 데이터의 분포에 따라 결정하는 것 같다.

### 결과

![스크린샷 2025-10-12 21.07.16.png](attachment:aa8f9345-dcf6-44f5-8b90-343c012a8ef5:%E1%84%89%E1%85%B3%E1%84%8F%E1%85%B3%E1%84%85%E1%85%B5%E1%86%AB%E1%84%89%E1%85%A3%E1%86%BA_2025-10-12_21.07.16.png)

이것을 보면 unused 즉, 사용이 되지 않은 쿠폰이 약 27만개가 있지만 이 중에서 use_ended_at이 현재보다 뒤에 있는 쿠폰이 하나도 없다. 즉, 전부 과거에 만료된 쿠폰인 것이다. 그렇다면 현재 테스트는 항상 어떤 컬럼도 조회하지 않고 0건을 반환할 것이다.

그럼 굳이 2개로 줄일 필요는 없는 것 같다. 왜냐면, 두 개로 줄이면 member_id와 used로 조회 후 use_ended_at 필터링을 거쳐야 하기 때문이다. 일단 3개로 두는 것이 좋은 선택인 거 같다.

### (member_id, use_ended_at, used) 인덱스

![image.png](attachment:d64afbbb-77e2-4e02-9a4c-9ffa5f5141ee:image.png)

![스크린샷 2025-10-14 오후 3.48.49.png](attachment:af396162-27ec-4e23-b3c9-0f3d5d044637:%E1%84%89%E1%85%B3%E1%84%8F%E1%85%B3%E1%84%85%E1%85%B5%E1%86%AB%E1%84%89%E1%85%A3%E1%86%BA_2025-10-14_%E1%84%8B%E1%85%A9%E1%84%92%E1%85%AE_3.48.49.png)

## 5. 월별 쿠폰 할인을 가장 많이 받은 회원 조회 성능 분석 및 성능 향상 (IndexPerformanceTest)

```java
@Test
void 월별_쿠폰_할인을_가장_많이_받은_회원_조회() throws InterruptedException {
    AtomicBoolean running = new AtomicBoolean(false);
    AtomicInteger requestCount = new AtomicInteger(0);
    AtomicLong totalElapsedTime = new AtomicLong(0);

    int statusCode = RestAssured.get("/marketing/max-coupon-discount-member?year=2019&month=1").statusCode();
    assertThat(statusCode).withFailMessage("월별 쿠폰 할인을 가장 많이 받은 회원 조회 API 호출에 실패했습니다. 테스트 대상 서버가 실행중인지 확인해 주세요.").isEqualTo(200);

    executeMultipleRequests(running, requestCount, totalElapsedTime, () -> {
        RestAssured.get(
                "/marketing/max-coupon-discount-member?year=2019&month=" + ThreadLocalRandom.current().nextInt(1, 6));
    });

    System.out.println("Total request count: " + requestCount.get());
    System.out.println("Total elapsed time: " + totalElapsedTime.get() + "ms");

    long averageElapsedTime = totalElapsedTime.get() / requestCount.get();
    System.out.println("Average elapsed time: " + totalElapsedTime.get() / requestCount.get() + "ms");

    assertThat(averageElapsedTime).isLessThanOrEqualTo(100L);
}

// MarketingController
@GetMapping("/marketing/max-coupon-discount-member")
public MonthlyMemberBenefit findMaxCouponDiscountAmountMemberByMonth(@RequestParam("year") int year,
                                                                     @RequestParam("month") int month) {
    return marketingService.findMaxCouponDiscountAmountMemberByMonth(Year.of(year), Month.of(month));
}

// MarketingService
@Transactional(readOnly = true)
public MonthlyMemberBenefit findMaxCouponDiscountAmountMemberByMonth(Year year, Month month) {
    return monthlyMemberBenefitRepository.findTopByYearAndMonthOrderByCouponDiscountAmountDesc(year, month)
            .orElseThrow(() -> new IllegalArgumentException("해당 월에 쿠폰을 사용한 회원 정보가 없습니다."));
}
```

### 문제

![image.png](attachment:8e607928-5cf4-4883-b3ef-06a6f6695088:image.png)

목표는 **Average elapsed time을 100ms**로 줄이는 것이다.

**EXPLAIN 결과**

![스크린샷 2025-10-12 21.24.36.png](attachment:5a077614-39fa-4a64-a84c-627c8e6f9749:%E1%84%89%E1%85%B3%E1%84%8F%E1%85%B3%E1%84%85%E1%85%B5%E1%86%AB%E1%84%89%E1%85%A3%E1%86%BA_2025-10-12_21.24.36.png)

결과를 보면 어떤 인덱스도 사용하지 않고, 약 68만개의 데이터를 모두 스캔하고 있다. 그리고 메서드에서 조건은 year과 month 밖에 없어보이지만 Order by를 coupon_discount_amount로 진행한 후에 가장 위에 있는 것을 가져오고 있다.

일단 order by를 기준으로 인덱스를 거는 것이 좋은 것은 맞다. 왜냐면 인덱스를 걸면 해당 인덱스 컬럼을 기준으로 정렬이 되어 있기 때문이다. 그래서 일단 order by 조건에 해당하는 컬럼으로 인덱스를 걸어보았다.

### Order by 조건 인덱스 결과

```sql
CREATE INDEX idx_member_benefit_coupon_discount_amount ON monthly_member_benefit(coupon_discount_amount);
```

![스크린샷 2025-10-12 21.59.26.png](attachment:db8b2080-5c37-4d3b-bb07-90de6efd99b6:%E1%84%89%E1%85%B3%E1%84%8F%E1%85%B3%E1%84%85%E1%85%B5%E1%86%AB%E1%84%89%E1%85%A3%E1%86%BA_2025-10-12_21.59.26.png)

![스크린샷 2025-10-12 22.00.02.png](attachment:b65634bc-3a25-4e72-8c23-80e69e993253:%E1%84%89%E1%85%B3%E1%84%8F%E1%85%B3%E1%84%85%E1%85%B5%E1%86%AB%E1%84%89%E1%85%A3%E1%86%BA_2025-10-12_22.00.02.png)

EXPLAIN 결과와 실행 결과 모두 만족스러운 결과를 보여주고 있다. 테스트 코드에서 month가 1~6 사이여서 해당 month를 1~6으로 바꿔가며 실행했음에도 동일한 결과를 보여주었다. 모든 쿼리가 항상 rows가 1을 확인하고 6ms만큼 줄어들었다.

무조건적으로 조회 성능만 본다면 추가하는 것이 맞겠지만 당장 필요하지 않다면 year, month를 추가하지 않는 것이 좋을 것 같다.

year, month만 인덱스하면 using filesort

그래서 year, month, coupon_discount_amount로 인덱스함

```sql
explain
select
        mmb1_0.id,
        mmb1_0.coupon_discount_amount,
        mmb1_0.created_at,
        mmb1_0.member_id,
        mmb1_0.modified_at,
        mmb1_0.month,
        mmb1_0.year
    from
        monthly_member_benefit mmb1_0
    where
        mmb1_0.year=?
        and mmb1_0.month=?
    order by
        mmb1_0.coupon_discount_amount desc
    limit
        ?;
```

### (year, month, coupon_discount_amount desc) 인덱스

![image.png](attachment:d540e720-3ea8-4fdb-982c-229279907b9d:image.png)

## 6. MultipleIssueRequestsTest 테스트 실행 후 문제 파악 및 분석

### 문제 정의

- 발급 제한이 있는 쿠폰이 동시성 문제로 인하여 초과 발급된다.

### 문제 발생 이유

![image.png](attachment:54362665-474b-4db6-9017-62fea0bc1c13:image.png)

- 여러 스레드에서 동시에 `getCoupon()`에 접근했을 때, 아직 발급 횟수가 늘어나지 않는 쿠폰을 동시 조회할 수 있음
- 따라서 여러 개의 스레드에서 동시에 한 쿠폰의 발급 횟수를 초과할 수 있음

## 7. MultipleIssueRequestsTest에 있는 문제 해결

### 문제 해결 방법

- 한 스레드에서 쿠폰을 가져올 때, 락을 걸고 가져오도록 함. 따라서 다른 스레드에서는 해당 쿠폰이 발급된 이후에만 접근할 수 있고, 따라서 동시성 문제 해결

![image.png](attachment:347f6f19-277d-467c-b9c0-077c1e1068b6:image.png)

![image.png](attachment:7baf8ee1-1b72-46e9-ab49-79fee7094029:image.png)

![image.png](attachment:fa51ad52-8202-4e76-9593-f05fcef751c8:image.png)

## 8. MultipleUseRequestsTest 테스트 실행 후 문제 파악 및 분석

### 문제 정의

- 사용 제한이 있는 쿠폰이 동시성 문제로 인하여 초과 사용된다.

### 문제 발생 이유

- 한 쿠폰의 사용 가능 횟수가 20회라 가정했을 때, 쿠폰 발급 자체는 20번 이상이 가능했음.
    
- 쿠폰 사용 가능 시간이 되었을 때, 수많은 유저가 사용하려고 시도하고, 따라서 동시성 문제가 발생함
    
    ![image.png](attachment:ed4df85a-7895-42ae-8cf1-a136f28fcffb:image.png)
    

## 9. MultipleUseRequestsTest에 있는 문제 해결

### 문제 해결 방법

- 발급된 쿠폰을 조회할 때, 원본 쿠폰도 락을 걸어, 다른 스레드에서 해당 원본 쿠폰과 연관된 발급 쿠폰을 조회할 수 없도록 한다.

![image.png](attachment:ddc969c0-b372-496e-9e66-d8ce61b2ee6f:image.png)

![image.png](attachment:594b8061-d592-4f71-8c9b-bb8dcdcd8a58:image.png)

![image.png](attachment:e5d1da7b-a6e9-40c5-b2a9-068052f6ef54:image.png)

## 10/11. 발급 제한 시간 이후에 회원에게 쿠폰이 발급되는 문제

### 문제 발생 이유
NTP 지연, 타임존 차이 등에 의하여 **시각 기준이 불일치하여** DB 기준 시각과 불일치한다.
### 문제 해결 방법
1. **애플리케이션 레벨에서 시간을 최대한 빠르게 확인하고, 해당 시간을 통해 여러 `LocalDateTime.now()` 를 동기화한다.**
```java
@Transactional  
public MemberCoupon issueMemberCoupon(Member member, Coupon coupon, LocalDateTime now) {  
    MemberCoupon memberCoupon = MemberCoupon.issue(member.getId(), coupon, now);  
    memberCouponRepository.save(memberCoupon);  
    return memberCoupon;  
}
```

```java
public static MemberCoupon issue(Long memberId, Coupon coupon, LocalDateTime now) {  
    coupon.issue(now);  
  
    MemberCoupon memberCoupon = new MemberCoupon();  
    memberCoupon.memberId = memberId;  
    memberCoupon.coupon = coupon;  
    memberCoupon.issuedAt = now;  
    memberCoupon.useEndedAt = now.plusDays(COUPON_USABLE_DAYS);  
    memberCoupon.modifiedAt = now;  
    memberCoupon.used = false;  
  
    return memberCoupon;  
}
```

```java
public void issue(LocalDateTime now) {  
    if (this.issueStartedAt.isAfter(now) || this.issueEndedAt.isBefore(now)) {  
        throw new IllegalArgumentException("쿠폰을 발급할 수 없는 시간입니다.");  
    }  
    if (couponStatus.isNotIssuable() || !this.issuable) {  
        throw new IllegalArgumentException("쿠폰을 발급할 수 없는 상태입니다.");  
    }  
    if (this.limitType.isNotIssueCountLimit()) {  
        return;  
    }  
    if (this.issueLimit <= this.issueCount) {  
        throw new IllegalArgumentException("쿠폰을 더 이상 발급할 수 없습니다.");  
    }  
    this.issueCount++;  
}
```
2. **DB 타임존과 애플리케이션 타임존을 일치시킨다.**
MYSQL : 확인 결과 SYSTEM 타임존, 명시적으로 UTC로 설정할 필요가 있다.
![[Pasted image 20251016133818.png]]
도커 컨테이너의 TZ를 UTC로 명확하게 맞추고, MySQL 또한 `--default-time-zone=+00:00`를 활용했다.
![[Pasted image 20251016134116.png]]
애플리케이션 : 명시적 설정이 없었다.
```java
@PostConstruct  
public void init() {  
    TimeZone.setDefault(TimeZone.getTimeZone("UTC"));  
}
```
- `spring.datasource.jdbc-url: jdbc:mariadb://localhost:33306/coupon?useSSL=false&serverTimezone=UTC&connectionTimeZone=UTC`
- `spring.jpa.properties.hibernate.jdbc.time_zone: UTC`
- `spring.jackson.time-zone=UTC`
## 12/13. 데이터 분석을 위해서 변경 일시를 참고하여 매일 회원이 사용한 쿠폰을 별도의 저장소로 마이그레이션 하는데, 어제 사용한 쿠폰이 오늘 마이그레이션 되지 않는 문제(MemberCouponController)
### 문제 발생 이유
트랜잭션 지연등에 의하여 어제 사용한 쿠폰이 오늘 사용한 것으로 기록될 수 있음 -> 마이그레이션에서 제외됨
### 문제 해결 방법
**멱등 설계 및 지연 버퍼 도입**

어제 05/15 11:00 ~ 05/16 13:00 까지 처리했다면,
오늘은 05/16 11:00 ~ 05/17 13:00 까지 처리하는 것이다.

이러면 05/16 11:00~13:00 부분이 중복 처리되고, 오버랩되기 때문에 마이그레이션 누락 문제는 발생하지 않는다.
단, 이러면 중복되어 시도되는 레코드가 발생하기 때문에 마이그레이션을 멱등하게 설계해야 한다.
## 14/15. 마케팅에서 데이터를 분석하던 중, 지난 달에 사용한 쿠폰이 이번 달에 할인 받은 내역으로 반영된 문제(MemberCouponController)
### 문제 발생 이유
기준 `LocalDateTime`이 정해져있지 않아, 처리 지연등에 의하여 동기화되지 못할 수 있음
### 문제 해결 방법
`LocalDateTime`을 한번에 생성하고, 이를 여러 곳에서 주입받아 사용한다.
## 16/17. 회원에게 쿠폰을 발급하는 과정에서 트랜잭션이 동작하지 않는 문제 (MemberCouponController)
### 문제 발생 이유
`@Transactional` 은 AOP 방식으로 작동하는데, 따라서 내부 메서드를 호출할 때에는 AOP가 적용되지 못함
### 문제 해결 방법
- 상위 메서드에도 `@Transactional` 을 적용
- 또는 해당 기능을 별도 도메인 서비스로 분리 
## 18/19. 회원이 쿠폰을 사용하면 마케팅에서 활용하기 위해 MonthlyMemberBenefit에 데이터를 적재하는데, 쿠폰을 사용했으나 데이터가 적재되지 않는 문제 파악 및 분석 (MemberCouponController)

### 문제 발생 이유
쿠폰 사용 즉시 직접 호출하는 코드를 통해서 마케팅 서비스가 호출되고, 마케팅 서비스가 쿠폰을 조회하려고 시도함
하지만 메인 트랜잭션이 커밋되기 전이라면 `REPEATABLE READ` 격리 수준에서 해당 쿠폰을 조회하지 못함
```java
@Transactional  
public void useCoupon(Long memberId, Long memberCouponId, LocalDateTime now) {  
    // 쿠폰 발급
    observers.forEach(observer -> observer.onUse(memberCoupon.getId()));  
}
```

```java
@Override  
@Async  
@Transactional  
public void onUse(Long memberCouponId) {  
    MemberCoupon memberCoupon = memberCouponRepository.findById(memberCouponId)  
            .orElseThrow(() -> new IllegalArgumentException();  
    // 데이터 적재
}
```
### 문제 해결 방법
옵저버 패턴을 통해서 직접 호출하지 않고, 이벤트를 발생한 후 해당 이벤트는 커밋 이후에 트리거 되도록 수정
```java
@Service  
@Slf4j  
@Transactional  
public class MemberCouponService {  
  
    private final ApplicationEventPublisher eventPublisher;
    private final MemberCouponRepository memberCouponRepository;
    private final MemberService memberService;
    
    @Transactional
    public void useCoupon(Long memberId, Long memberCouponId, LocalDateTime now) {  
        // 쿠폰 사용
        eventPublisher.publishEvent(new MemberCouponUseEvent(memberCoupon.getId()));  
    }
}
```

```java
public record MemberCouponUseEvent(Long memberCouponId) { }
```

```java
@Component  
public class MemberCouponEventListener {  
  
    private final List<MemberCouponObserver> observers;  
  
    public MemberCouponEventListener(List<MemberCouponObserver> observers) {  
        this.observers = observers;  
    }  
  
    @TransactionalEventListener(phase = TransactionPhase.AFTER_COMMIT)  
    public void handleCouponUsed(MemberCouponUseEvent event) {  
        observers.forEach(observer -> observer.onUse(event.memberCouponId()));  
    }  
}
```