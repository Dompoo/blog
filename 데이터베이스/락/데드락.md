## 비관적 락에서의 데드락
- 데드락이란 두 트랜잭션이 서로의 락을 획득하기 위해 무한 대기하는 현상이다. (보통 무한대기하지는 않고, 타임아웃된다.)
- 시나리오
    - 트랜잭션1 : 회원1 조회 성공, 락 획득
    - 트랜잭션2 : 회원2 조회 성공, 락 획득
    - 트랜잭션1 : 회원 2 조회 시도, 락 획득 대기
    - 트랜잭션2 : 회원 1 조회 시도, 락 획득 대기
    - — 무한대기 —
## 해결 방법

1. **동일 테이블 락 획득 순서 불일치**

```java
void run(int id1, int id2) {
	Member member1 = memberDB.find(id1);
	Member member2 = memberDB.find(id2);
}
```

: `run(1, 2)`와 `run(2, 1)`을 동시에 실행시키면 데드락에 걸릴 수 있다.

해결방법 : 순서를 항상 일치시킨다.

```java
void run(int id1, int id2) {
	int minId = Math.min(id1, id2);
	int maxId = Math.max(id1, id2);
	Member member1 = memberDB.find(minId);
	Member member2 = memberDB.find(maxId);
}
```

1. **여러 테이블에 대한 락 획득**

```java
void run1(int memberId, int productId) {
	Member member = memberDB.find(memberId);
	Product product = productDB.find(productId);
}

void run2(int memberId, int productId) {
	Product product = productDB.find(productId);
	Member member = memberDB.find(memberId);
}
```

: `run1(1, 2)`, `run2(1, 2)` 를 동시에 실행시키면 데드락에 걸릴 수 있다.

해결방법

- 전역적인 락 획득 테이블 우선순위 정의
- 락 획득 헬퍼 클래스를 통해 락 획득
- `테이블명+ID` 를 정렬한 순서를 기준으로 락 획득
- 사실 뾰족한 방법은 없다. 낙관적 락으로의 전환도 고려해야 한다.

1. **너무 긴 트랜잭션**

: 트랜잭션이 길어질수록 락 획득 시간이 늘어나며, 다른 락을 추가 획득할 가능성이 높고, 다른 트랜잭션과의 충돌 확률을 높이게 된다.

해결방법

- 외부 API 호출은 락을 획득하고 수행하지 않는다.
- 복잡한 계산 전후로 락을 획득한다.