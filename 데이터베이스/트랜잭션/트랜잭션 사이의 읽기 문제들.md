### Dirty reads
: 커밋되지 않은 데이터를 읽어서 나중에 롤백될 수 있는 불안정한 정보에 의존 → 실제로는 존재하지 않게 될 데이터를 기반으로 비즈니스 로직이 실행될 위험이 있다.

```java
@Test
void dirtyReading() throws SQLException {
    final var connection = dataSource.getConnection();
    connection.setAutoCommit(false); // 트랜잭션 시작
    userDao.insert(connection, NEW_USER);

    new Thread(RunnableWrapper.accept(() -> {
        final var subConnection = dataSource.getConnection();
        final var actual = userDao.findByAccount(subConnection, "gugu");
        assertThat(actual).isNotNull(); // 아직 커밋되지 않았는데, 다른 곳에서 읽을 수 있다.
    })).start();
}
```
### Non-repeatable reads
: 같은 트랜잭션 내에서 동일한 조회를 반복했을 때 다른 결과가 나오는 일관성 문제
```java
@Test
void noneRepeatable() throws SQLException {
    userDao.insert(dataSource.getConnection(), NEW_USER);
    final var connection = dataSource.getConnection();
    connection.setAutoCommit(false); // 트랜잭션 시작

    final var firstRead = userDao.findByAccount(connection, "gugu");

    new Thread(RunnableWrapper.accept(() -> {
        final var subConnection = dataSource.getConnection();
        final var anotherUser = userDao.findByAccount(subConnection, "gugu");
        anotherUser.changePassword("qqqq"); // 다른 곳에서 데이터 수정
        userDao.update(subConnection, anotherUser);
    })).start();

    final var secondRead = userDao.findByAccount(connection, "gugu");

    assertThat(secondRead.getPassword()).isNotEqualTo(firstRead.getPassword()); // 한 트랜잭션에서 같은 데이터에 대한 두 읽기의 데이터가 다르다.
}
```
### Phantom reads
: 범위 조회에서 이전에 없던 새로운 레코드가 나타나는 현상 → 집계나 통계 작업에서 예상치 못한 결과를 만들어낼 수 있다.
```java
@Test
void phantomReading() throws SQLException {
    userDao.insert(dataSource.getConnection(), NEW_USER);
    final var connection = dataSource.getConnection();
    connection.setAutoCommit(false);

    final var firstReadSize = userDao.findGreaterThan(connection, 1).size();

    new Thread(RunnableWrapper.accept(() -> {
        final var subConnection = dataSource.getConnection();
        userDao.insert(subConnection, NEW_USER2); // 다른 곳에서 데이터 삽입
    })).start();

    final var secondReadSize = userDao.findGreaterThan(connection, 1).size();

    assertThat(secondReadSize).isNotEqualTo(firstReadSize); // 한 트랜잭션에서 같은 데이터에 대한 두 읽기의 데이터가 다르다.
}
```