- 특정 칼럼 값을 기반으로 데이터의 물리적 위치를 빠르게 찾을 수 있도록 해준다.
- `WHERE/JOIN/ORDER BY` 절에 자주 사용되는 칼럼을 인덱스로 저장하면 검색 속도 향상이 있다.
- 하지만 추가, 수정 작업에서는 속도가 오히려 조금 느려진다.
- [[B+Tree 인덱스|B-Tree]] 기반이기 때문에, 검색 시간이 `O(logN)`이다.
- [[인덱스 잘 걸기]] 문서를 참고하여 적절한 컬럼에 인덱스를 설정하자.
- 인덱스를 설정하기 좋은 컬럼
    - WHERE, JOIN, ORDER BY, GROUP BY에 자주 사용되는 컬럼
    - 데이터 중복도가 낮고(카디널리티가 높고), 값의 분포가 넓은 컬럼
    - 전체 데이터 중 일부(10~15% 이하)를 자주 조회하는 컬럼
    - INSERT, UPDATE, DELETE가 자주 일어나지 않는 컬럼
- 저장 방식 유형
    - **[[클러스터링 인덱스|clustered]]**
        - 테이블의 실제 데이터가 인덱스의 순서와 동일하게 저장 (리프 노드가 실제 데이터)
        - 한 테이블에 1개만 생성 가능, 테이블 내에 같이 저장
        - 데이터 삽입/삭제시 전체 재정렬
        - 범위 검색, 정렬에 유리
        - PK 제약조건을 사용하면 pk칼럼으로 clustered index를 생성한다.
    - **non-clustered**
        - 인덱스에 주소만 저장 → 주소 찾기 + 실제 데이터 찾기로 IO가 2번 발생
        - 한 테이블에 여러개 생성 가능
        - 특정 값 검색에 유리
- 특성/기능 유형
    - composite
        - 둘 이상의 칼럼을 조합하여 만든 인덱스
        - 여러 칼럼을 조건으로 자주 검색할 때 유용
    - [[커버링 인덱스|covering]]
        - 쿼리에 필요한 모든 칼럼이 인덱스에 포함된 경우
        ex) `SELECT name, age FROM users WHERE email = 'user@example.com'` 의 경우 name, age, email로 인덱스를 구성한 경우다.
        - 읽기 성능이 매우 빠르지만, 인덱스 크기가 커질 가능성 ↑
    - unique
        - 지정된 칼럼들에 대한 중복을 허용하지 않음
        - PK 제약조건, UNIQUE 제약조건을 사용하면 자동으로 생성된다.(unique non-clustered)
- 인덱스 관련 문서: [[인덱스를 읽는 방법]], [[실행 계획 확인]], [[Hash 인덱스]], [[R-Tree 인덱스]]
- 생성 방법
    - `CREATE INDEX 인덱스명 ON 테이블명(컬럼1, 컬럼2, ...)`
    - Spring Data JPA에서는 `@Index` 를 통해서 인덱스를 생성해줄 수 있다. (DDL-AUTO)