
**초기 : 테이블 전부 분리**

...

**문제** : Segment가 추가되면서 JPA 적용 불가 (ElementCollection 점령기)
**방법**
- 테이블을 분리하는 방식을 유지하고 싶다면
	- **Segment를 엔티티로 승격**
		- 방법 : `Segment`에 Id 추가
		- 장점
			- 수정하기 매우 쉬움
			- JPA를 적극 사용하는 환경에서의 사실상 정답
			- 인덱스 사용 가능
		- 단점
			- JPA 수준의 복잡성(순서 보존, cascade) 증가
			- 테이블 조인에 의한 속도 저하
	- **JDBC를 통한 직접 SQL 작성**
		- 방법 : `CourseRepository`를 `JdbcTemplate` 활용하여 직접 구현, `Segment` 테이블에 id추가
		- 단점
			- 수정하기 어려움
			- JDBC/SQL 관련 코드를 유지보수하기 어려움
			- 테이블 조인에 의한 속도 저하
- 한 칼럼에 저장하는 방식들
	- **JSON 타입**
		- 방법 : `AttributeConverter<List<Segment>, String>` 구현
		- 장점
			- 조인 연산이 없음
			- 중간 테이블들을 따로 조회할 일이 없으므로 의미론적으로도 맞음
		- 단점
			- 인덱스 사용 불가 -> findAll 해서 애플리케이션에서 처리 (속도, 메모리 문제)
	- **MultiLineString 타입** (이때는 몰랐음)
		- 방법 : `AttributeConverter<List<Segment>, MultiLineString>` 구현
		- 장점
			- 조인 연산이 없음
			- 인덱스 사용 가능
		- 단점
			- 없음
**결정**
비즈니스가 어떻게 변할지 몰랐으므로, 수정가능성과 유지보수성이 1순위 가치였음
따라서 속도나 메모리 면에서 문제가 있을 가능성이 존재했지만, 서울 100개 코스 수준에서는 괜찮았던 **JSON 타입** 선택

...

**문제** : 코스 데이터 추가 -> 인덱스 미사용에 의한 조회 속도 저하, 메모리 부하 (속도 점령기)
**방법**
- 테이블을 분리하여 공간데이터를 노출시키는 방법
	- Segment를 엔티티로 승격 : 결국 조인에 의해서 속도 부족
- 정책적으로 풀어내는 방법
	- 코스의 중심점을 따로 저장
	- 코스의 일부점들을 따로 저장하여 테이블로 분리
	- -> 모두 정책적으로 반려됨
- MultiLineString
- MongoDB로 옮기기
	- 문서가 잘 되어있음 & Spring Data Mongo 구현도 훌륭하고 비용이 적음
**결정**
많이 임베딩된 모델을 가지며, 조회 성능이 중요하고, 중간 데이터 조회가 적으며, 여러 문서간 트랜잭션이 불필요
한국어로 된 친절한 공식 문서 존재하는 MongoDB로 이동