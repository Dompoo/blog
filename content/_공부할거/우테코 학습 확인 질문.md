## 객체지향
---
**Q. 객체지향의 대표적인 특징 네 가지(추상화, 캡슐화, 상속, 다형성)를 설명해주시겠습니까?**  
**가능한 한 “직접 구현 경험” 또는 “현실 서비스 개발 맥락에서 왜 중요한지”까지 언급해주시면 더 좋습니다.**

먼저 캡슐화부터 설명드리면, 캡슐화는 구현을 내부로 숨기고, 인터페이스만을 노출시켜 유지보수성을 향상시키는 개념입니다. 구현이 외부로 드러나도록 설계하면 변경사항이 발생했을 때, 외부와 해당 객체 모두 수정이 필요하지만, 캡슐화를 사용하면 객체 내부만 수정하면 되기 때문에 유지보수성이 향상됩니다.
제 프로젝트에서는 두 좌표 사이의 구면 거리를 구하는 로직이 존재했는데요, 이 로직을 Line이라는 객체 안으로 캡슐화 시켜서 여러 곳에서 해당 로직을 재사용할 수 있었습니다. 또한 추후에 구면 거리처럼 자세한 계산보다는 빠른 직선 거리 계산을 채택하게 될 때에도 해당 객체의 구현부만 수정하면 됩니다.

추상화는 어떠한 개념의 공통성을 추출하는 것입니다. 예를 들어 개와 고양이 모두 밥을 먹고 잠을 잔다는 점에서 동물이라는 개념으로 추상화할 수 있습니다. 이렇게 추상화하면 불필요한 세부사항을 제거하고 본질적인 부분을 드러낼 수 있습니다. 제 프로젝트에서는 GPX 파일을 어딘가에 저장해야 했는데요, 이 구현체로 구글 드라이브를 채택하게 되었습니다. 하지만 이것만을 사용하는 것이 아니라 GPX 저장소 라는 인터페이스로 추상화했습니다. 이 추상화 덕분에 해당 저장소를 사용하는 객체들에서는 본질적인 부분에만 집중하여 작성해낼 수 있었습니다.

하지만 추상화의 진짜 장점은 다형성으로 이어지는데요, 이렇게 추상화된 객체들은 다형성을 갖습니다. 즉, GPX 저장소에는 구글 드라이브 또는 S3 버킷 같은 것들이 올 수 있다는 뜻입니다. 이런 다형성 덕분에 GPX 저장소를 참조하는 다른 시스템에서는 구현체가 다른 것으로 바뀌더라도 코드를 수정할 필요가 없어지고, 이는 유지보수성을 크게 향상시키고, 유연한 시스템을 구축할 수 있도록 합니다.

상속은 부모의 구현들을 일부 사용하여 자식 클래스를 작성해내는 방법입니다. 자바에서는 extends로 대표됩니다. 이러면 자식 클래스를 만들 때 매번 비슷한 코드를 작성할 필요가 없으므로 구현하기 훨씬 쉬워집니다. 예를 들어 Spring Data JPA에서는 CRUDRepository나 PagingAndSortingRepository를 구현해두어 개발자가 구현체를 작성하는 수고로움을 덜었습니다.

**Q. 캡슐화는 “정보 은닉”과도 연결되는데요, 정보 은닉을 제대로 하지 않았을 때 시스템에서 어떤 문제가 발생할 수 있습니까?  
또한 Java에서 정보 은닉을 제대로 하려면 어떤 언어적 도구들을 어떻게 조합해야 한다고 생각하십니까?**

정보 은닉을 지키지 않으면 수많은 문제점들이 야기되는데요. 먼저 생각나는 것은 테스트가 깨지기 쉬워지는 부분입니다. 세부 구현이 아니라 외부 API를 테스트해야 구현이 수정되었을 때 테스트가 깨지지 않습니다. 하지만 정보 은닉을 제대로 지키지 않은 시스템에서는 세부 구현의 테스트를 막을 도구가 없고, 따라서 깨지는 테스트를 작성하기 매우 쉬워집니다.
또한 순수하게 보안적 문제도 발생하기 쉬울 것 같은데요. 예를 들어 회원의 비밀번호를 은닉하지 않은 경우에 보안 이슈가 발생합니다.

자바에서는 이러한 것들을 접근 제어자를 통해 수행합니다. public protected package private private 접근 제어자들을 통해 정보와 기능들의 접근을 제어하고, 이를 통해 원하는 부분만 외부에 노출할 수 있습니다.

**Q. 접근 제어자만으로 정보 은닉을 달성할 수 없는 대표적인 상황 3가지를 설명해주세요.**

getter를 통해서 깨지기 쉽습니다. 별 생각없이 추가해둔 getter 때문에 내부 구현이 외부에 작성될 수 있습니다. 이 부분은 일단 최대한 getter를 추가하지 않는 방향으로 노력하되, 어쩔 수 없이 추가한 경우에는 개발자의 역량이 중요해집니다. 더 캡슐화할 수 있는 부분들을 지속적으로 고민하고 리팩터링하는 것이 중요합니다.

또한 setter를 통해서도 깨질 수 있는데요. setter를 통해 내부 상태를 수정하게 된다면 해당 객체가 원하는 대로 작동하지 않을 수 있습니다. setter 또한 getter와 비슷하게 개발자의 주의가 필요합니다. 제 경험상 거의 모든 setter는 적절한 책임을 통해 대체할 수 있었습니다. 따라서 최대한 작성하지 않는게 답이라고 생각합니다.

마지막 한가지는 잘 모르겠습니다.

**Q. 추상화를 “너무 일찍” 혹은 “너무 과하게” 해서 오히려 유지보수가 더 어려워지는 상황을, 본인 경험 또는 상상 가능한 시나리오 기준으로 2가지 이상 설명해주시겠습니까?**

추상화의 가장 큰 단점은 클래스의 개수가 늘어나고 따라서 관계를 파악하기 어려워진다는 점입니다. 제 프로젝트에서는 스프링 배치와 관련되어 추후 재사용될 가능성이 높다고 판단한 Reader, Processer, Writer를 각자의 클래스로 구현한 적이 있습니다. 하지만 이 때문에 팀원들의 코드 이해력이 낮아졌던 상황이 있었습니다.
또한 코스를 나타내는 파일은 GPX와 KML 파일 두 종류가 존재하는데, 프로젝트 초반에 KML 파일을 기준으로 추상화했다가, 추후에 GPX 도 지원하게 되면서 오히려 인터페이스를 수정해야 하는 상황도 발생했습니다.

**Q. “추상화를 할지 말지, 언제 할지”를 결정할 때 본인이 쓰는 기준이 무엇인지, 우테코나 실제 프로젝트에서 “처음에는 인터페이스/추상 클래스로 빼놨다가, 나중에 되돌리거나 단순화한 경험” 혹은 반대로 “처음엔 구체 타입 하나로 가다가, 나중에야 추상화한 경험”이 있다면 어떤 판단 근거로 리팩터링을 했는지**

저는 이러한 경험들을 바탕으로 추상화를 할지 말지에 대한 팀적인 컨벤션과 근거를 만들어야 한다고 생각했고, 이에 '변화기대지수'를 모든 코드에 걸쳐서 책정한 적이 있습니다. 변화기대지수는 모든 부분에 대하여 '변경 가능성'과 '변경시 영향을 미치는 다른 시스템의 크기'와 '변경을 수정하는데 걸리는 노력'을 모두 합해서 계산해내는 값으로, 이 값이 높은 경우에는 추상화가 필요하고, 낮은 경우에는 추상화하지 않는 전략을 택했습니다. 이는 팀적으로 받아들여졌고, 코드 일부에 대한 역 추상화가 진행되었습니다.

**Q. 상속을 “코드 재사용” 관점으로만 볼 때 생기는 문제점은 무엇일까요?**

상속을 코드 재사용 관점으로만 보게 되면 is-a 관계가 아닌 경우에도 상속하게 될 수 있습니다. 가장 유명한 예로는, 새 하위에 재사용을 위한 펭귄이라는 자식 클래스를 상속을 통해 구현한 경우, 사실 새는 날 수 있지만 펭귄은 날 수 없는 문제가 발생할 수 있습니다.

이 문제는 사실 자바에서 부모에 정의된 메서드들은 자식 클래스에서 더 좁은 접근 제어 범위를 가질 수 없기 때문에 발생하는데요, 쉽게 말해 부모에서 public 이었던 메서드는 자식에서도 public이게 됩니다.

따라서 상속은 무분별하게 사용하면 안되며, 코드 재사용성을 누리고 싶지만 is-a 관계가 아니거나, 추후에 깨질 위험이 있는 경우에는 조합을 활용하면 됩니다.
조합의 경우에는 모든 구현이 자식 클래스에 존재하고, 필요한 경우에만 노출할 수 있기 때문에 위 문제가 덜 발생합니다.