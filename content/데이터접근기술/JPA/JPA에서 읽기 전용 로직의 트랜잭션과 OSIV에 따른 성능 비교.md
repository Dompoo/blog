## OSIV OFF 상황에서 트랜잭션 유무 비교

- **@Transactional 미사용**
    - 각 쿼리마다 자동으로 새로운 트랜잭션이 생성되어 즉시 커밋된다
    - 영속성 컨텍스트의 생명주기가 매우 짧아져 1차 캐시, 지연 로딩, 변경 감지 등의 기능을 제대로 활용하지 못한다
    - 안정성을 버리는 대신 성능을 극단적으로 최적화할 수 있는 방법 중 하나다
- **@Transactional**
    - JPA의 모든 기능을 사용할 수 있다 (1차 캐시, 지연 로딩, 변경 감지, 쓰기 지연)
    - 트랜잭션 관리 오버헤드와 더티 체킹, 플러시 등의 오버헤드가 발생하여 성능이 상대적으로 느리다
    - 하나의 트랜잭션 내에서 여러 쿼리의 일관성이 보장된다
- **@Transactional(readOnly = true)**
    - 더티 체킹 비활성화, 1차 캐시 최적화(스냅샷 생성 안함), 플러시 작업 생략 등의 JPA 최적화가 일어난다
    - 하이버네이트 레벨에서 읽기 전용 최적화가 적용된다
    - DB 락 또한 읽기 전용 락으로(동시 읽기 가능) 설정된다
    - 일관성은 지키면서 읽기 성능을 최적화한다

## OSIV ON 상황에서 트랜잭션 유무 비교

- **참고사항**
    - OSIV가 켜져있으므로 영속성 컨텍스트가 HTTP 요청 전체 범위로 확장된다
    - 서비스 레이어 트랜잭션 종료 후에도 영속성 컨텍스트가 유지된다 → 지연 로딩을 가능케 한다.
- **@Transactional**
    - 서비스 레이어에서는 일반 트랜잭션으로 동작한다
    - 트랜잭션 종료 후 뷰에서 지연 로딩 시 자동으로 읽기 전용 트랜잭션이 생성된다
    - 영속성 컨텍스트가 요청 전체에 걸쳐 유지되므로 1차 캐시 효과가 크다
- **@Transactional(readOnly = true)**
    - OSIV OFF 상황과 비슷하나, 영속성 컨텍스트 범위만 확장되어 있다
    - 따라서 뷰에서도 지연 로딩이 가능하다 (새로운 읽기 전용 트랜잭션을 통하여)
    - 전체적으로 읽기 최적화 효과를 얻을 수 있다
- **@Transactional 미사용**
    - 영속성 컨텍스트는 OSIV에 의해 유지되므로 지연 로딩이 동작한다
    - 지연 로딩 발생 시 자동으로 읽기 전용 트랜잭션이 생성된다
    - 사실상 성능 최적화의 이점이 사라진다 (각 지연 로딩마다 새로운 트랜잭션 생성)
    - 오히려 예측하기 어려운 다수의 트랜잭션이 생성될 수 있어 성능상 불리할 수 있다

## 성능 고려사항

### **커넥션 관리**

- @Transactional 사용: 트랜잭션 범위 내에서 커넥션 재사용
- @Transactional 미사용: 각 쿼리마다 새로운 커넥션 생성으로 커넥션 풀 부담 증가

### **메모리 사용량**

- OSIV ON: 영속성 컨텍스트가 오래 유지되어 메모리 사용량 증가
- OSIV OFF + @Transactional 미사용: 매우 짧은 영속성 컨텍스트 생명주기로 메모리 효율적

### **일관성 vs 성능**

- @Transactional 사용: 일관성 보장, 적절한 성능
- @Transactional(readOnly = true): 읽기 일관성 보장, 최적화된 성능
- @Transactional 미사용: 일관성 희생, 극단적 성능 최적화 (단순 조회 시에만 유효)