# 락

작성일: 2025년 10월 15일 오후 2:34

- 여러 트랜잭션이 공유 자원에 동시 접근할 때 생기는 데이터 정합성 문제를 해결하기 위한 수단이다.
- 예를 들어, 쿠폰 사용횟수에 제한이 있고 여러 곳에서 쿠폰을 사용할 수 있다면 락을 걸고 쿠폰을 사용하도록 해야 한다. (아닌 경우 사용횟수를 넘어설 수 있다.)

## 락의 종류

- 크게 **낙관적 락과 비관적 락**으로 나뉜다.

### 비관적 락

- 충돌이 발생할 것을 가정하고, 미리 락을 건다.
- 위 예시에서 한 쿠폰에 대하여 스레드1이 락을 걸면, 나머지 스레드2,3,4는 락을 획득하기 위해 대기하게 된다.
- 즉, 병렬적으로 처리되던 서버가 쿠폰 사용에 대해서만큼은 직렬적으로 작동하게 된다.
- 비관적 락은 **공유락과 배타락**으로 나뉜다.
- **공유락** : 읽기 작업에 사용하며, 다른 트랜잭션도 읽기는 가능하나, 쓰기가 안된다.
- **배타락** : 쓰기 작업에 사용하며, 다른 트랜잭션은 읽기도 안된다.

### 낙관적 락

- 충돌이 드물 것을 가정하고, 커밋 시점에 충돌을 검사하는 방식이다.
- 위 예시에서 한 쿠폰에 대하여 스레드1,2,3,4가 모두 v1인 쿠폰을 조회한다. 그 후, 스레드1이 가장 빨리 사용하게 되어 쿠폰은 v2가 되고, 스레드2,3,4는 사용하려고 할 때에, 버전이 불일치하는 것을 감지, 롤백한다.

### 장단점

- 비관적 락
    - 미리 락을 걸기 때문에, 무조건 성공한다.
    - 하지만 그 동안 다른 스레드가 작업하지 못하므로 느리다.
    - **데드락이 발생할 수 있다.**
- 낙관적 락
    - 기본적으로 락을 걸지 않아 빠르다.
    - 충돌이 자주 발생하는 경우 오버헤드가 증가한다.

## 사용 방법

- Spring Data JPA를 사용할 때에는 애노테이션을 바탕으로 손쉽게 락을 걸 수 있다.

```java
@Lock(LockModeType.PESSIMISTIC_WRITE)
@Query("select c from Coupon c where c.id = :id")
Optional<Coupon> findByIdWithLock(@Param("id") Long id);
```

- `LockModeType` 이 필수이며 옵션은 다음과 같다.
    - `OPTIMISTIC` , `READ` : 낙관적 락
    - `OPTIMISTIC_FORCE_INCREMENT` , `WRITE` : 낙관적 락, 수정하지 않았어도 버전 증가한다.
    - `PESSIMISTIC_READ` : 비관적 락 (공유락)
    - `PESSIMISTIC_WRITE` : 비관적 락 (배타락)
    - `PESSIMISTIC_FORCE_INCREMENT` : 비관적 락, 베타락을 획득하며 낙관적락의 버전도 증가시킨다.
    - `NONE`
- 낙관적 락을 사용하기 위해서는 엔티티에 `@Version` 애노테이션도 붙여야 한다.

## 비관적 락에서의 데드락

- 데드락이란 두 트랜잭션이 서로의 락을 획득하기 위해 무한 대기하는 현상이다. (보통 무한대기하지는 않고, 타임아웃된다.)
- 시나리오
    - 트랜잭션1 : 회원1 조회 성공, 락 획득
    - 트랜잭션2 : 회원2 조회 성공, 락 획득
    - 트랜잭션1 : 회원 2 조회 시도, 락 획득 대기
    - 트랜잭션2 : 회원 1 조회 시도, 락 획득 대기
    - — 무한대기 —

### 주로 발생하는 원인과 해결 방법

1. **동일 테이블 락 획득 순서 불일치**

```java
void run(int id1, int id2) {
	Member member1 = memberDB.find(id1);
	Member member2 = memberDB.find(id2);
}
```

: `run(1, 2)`와 `run(2, 1)`을 동시에 실행시키면 데드락에 걸릴 수 있다.

해결방법 : 순서를 항상 일치시킨다.

```java
void run(int id1, int id2) {
	int minId = Math.min(id1, id2);
	int maxId = Math.max(id1, id2);
	Member member1 = memberDB.find(minId);
	Member member2 = memberDB.find(maxId);
}
```

1. **여러 테이블에 대한 락 획득**

```java
void run1(int memberId, int productId) {
	Member member = memberDB.find(memberId);
	Product product = productDB.find(productId);
}

void run2(int memberId, int productId) {
	Product product = productDB.find(productId);
	Member member = memberDB.find(memberId);
}
```

: `run1(1, 2)`, `run2(1, 2)` 를 동시에 실행시키면 데드락에 걸릴 수 있다.

해결방법

- 전역적인 락 획득 테이블 우선순위 정의
- 락 획득 헬퍼 클래스를 통해 락 획득
- `테이블명+ID` 를 정렬한 순서를 기준으로 락 획득
- 사실 뾰족한 방법은 없다. 낙관적 락으로의 전환도 고려해야 한다.
1. **너무 긴 트랜잭션**

: 트랜잭션이 길어질수록 락 획득 시간이 늘어나며, 다른 락을 추가 획득할 가능성이 높고, 다른 트랜잭션과의 충돌 확률을 높이게 된다.

해결방법

- 외부 API 호출은 락을 획득하고 수행하지 않는다.
- 복잡한 계산 전후로 락을 획득한다.

## 락과 인덱스의 관계

- 인덱스는 락의 범위를 결정한다. (DB마다 결과 자체는 다 다름)
    - 인덱스가 없어 전체 테이블 스캔시 → 모든 행이 락에 걸린다. → 동시성이 떨어진다.
    - 인덱스가 있어 테이블을 조금만 스캔시 → 해당 행들만 락이 걸린다.
    - 인덱스로 커버되어 원하는 행들만 스캔시 → 원하는 행들에만 락이 걸린다.