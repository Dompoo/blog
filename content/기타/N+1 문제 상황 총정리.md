# N+1 문제 상황 총정리

작성일: 2025년 5월 20일 오전 9:46
카테고리: JPA

```java
@Entity
public class Reservation {

    @ManyToOne(fetch = FetchType.LAZY)
    public User user;
}

@Entity
public class User {

    @OneToMany(mappedBy = "user", fetch = FetchType.LAZY)
    private List<Reservation> reservations = new ArrayList<>();
}
```

### List<Reservation> 을 찾고 하나씩 Member를 찾는다.

```java
@Transactional
public void print2() {
    List<Reservation> reservations = reservationRepository.findAll();

    for (Reservation reservation : reservations) {
        User user = reservation.user;
        System.out.println(user);
    }
}
```

- LAZY / EAGER 인 경우 : 각 `Reservation` 에 대하여 해당하는 `User` 를 찾기 위해 쿼리가 N개 더 나간다.
    - 단 LAZY는 실제 사용할 때 N개 쿼리가 나가지만, EAGER는 Reservations 로딩시 바로 나간다.
- **1 + N**
    - `SELECT * FROM RESERVATION`
    - `SELECT * FROM USER WHERE USER.id = ?`  X N번
- `Fetch Join` 이나 `BatchSize` 를 통해 해결해볼 수 있다.
    - Fetch Join 을 통해 User를 모두 즉시로딩하여 쿼리한다. ( 1쿼리 )
    - BatchSize 를 통해 User를 지연로딩할 때, 여러 개씩 지연로딩 한다. ( N / size 쿼리 ) → BatchSize 애노테이션을 User에 붙인다.

### Member를 찾고 속한 List<Reservation>을 찾는다.

```java
@Transactional
public void print() {
    User user = userRepository.findById(1L).get();

    user.reservations().forEach(System.out::println);
}
```

- LAZY 인 경우 : `User` 가 갖고 있는 `Reservation` 들을 찾기 위해 쿼리가 1개 더 나간다. : **1 + 1**
    - `SELECT * FROM USER WHERE USER.id = ?`
    - `SELECT * FROM RESERVATION WHERE RESERVATION.user_id = ?`
- EAGER 인 경우 : `User` 와 `Reservation` 테이블을 조인하여 최초에만 쿼리가 1개 나간다. : **1**
    - `SELECT * FROM USER JOIN RESERVATION WHERE USER.id = ?`
    - 단, `findById()` 대신에 JPQL 쿼리/메서드명 추론 쿼리를 사용하면 동일하게 **1 + 1**로 나간다.

![image.png](N+1%20%EB%AC%B8%EC%A0%9C%20%EC%83%81%ED%99%A9%20%EC%B4%9D%EC%A0%95%EB%A6%AC%201f930154715b80328d22cfbb849831a0/image.png)