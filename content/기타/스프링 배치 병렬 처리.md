# 스프링 배치 병렬 처리

작성일: 2025년 6월 17일 오후 3:36
카테고리: Spring Batch

- **Multi-threaded Step**
    - 여러 chunk를 여러 스레드로 분할하여 처리하는 방식이다.
    - Step의 TaskExecutor를 설정하면 된다.
    
    ```java
    @Bean
    public TaskExecutor taskExecutor() {
        return new SimpleAsyncTaskExecutor("spring_batch");
    }
    
    @Bean
    public Step multiThreadedStep(TaskExecutor taskExecutor) {
        return new StepBuilder("multiThreadedStep", jobRepository)
                .<Person, Person>chunk(100, transactionManager)
                .reader(itemReader())
                .processor(itemProcessor())
                .writer(itemWriter())
                .taskExecutor(taskExecutor) // TaskExecutor 설정
                .build();
    }
    ```
    
    - 간단한 설정으로 추가할 수 있다.
    - 주의 : reader, processor, writer가 thread-safe하게 구현되어야 한다.
- **Parallel Steps**
    - 여러 step을 병렬로 처리하는 방식이다.
    - Flow를 통해 병렬 처리 구간을 나누고, spit을 사용하면 된다.
    
    ```java
    @Bean
    public Job parallelStepsJob() {
        Flow flow1 = new FlowBuilder<Flow>("flow1")
                .start(step1())
                .build();
    
        Flow flow2 = new FlowBuilder<Flow>("flow2")
                .start(step2())
                .build();
    
        return new JobBuilder("parallelStepsJob", jobRepository)
                .start(flow1)
                .split(new SimpleAsyncTaskExecutor()).add(flow2) // flow1과 flow2를 병렬 실행
                .next(step3()) // flow1, flow2 종료 후 step3 실행
                .build();
    }
    ```
    
- **Partitioning**
    - 데이터셋을 나눠서 동일한 step을 여러 worker에게 나눠주는 방식이다.
    - worker는 여러 스레드, 또는 여러 원격 서버로 지정할 수도 있어서 수평확장성이 좋다.
    - 데이터셋을 나눌 Partitioner를 지정해주고, TaskExecutor가 각 worker에게 실행을 위임하게 된다.
    - TaskExecutor를 다른 구현체를 사용하여 worker를 어떻게 지정할지 선택하게 된다.
    
    ```java
    @Bean
    public Step managerStep(JobRepository jobRepository, Step workerStep, Partitioner partitioner) {
        return new StepBuilder("managerStep", jobRepository)
                .partitioner("workerStep", partitioner) // Partitioner 지정
                .step(workerStep) // 작업 대상 Step
                .taskExecutor(new SimpleAsyncTaskExecutor()) // Worker를 실행할 TaskExecutor
                .build();
    }
    ```
    
- **Remote Chunking**
    - I/O 집약적인 ItemReader와 CPU 집약적인 ItemProcessor/ItemWriter를 분리하는 방식이다.
    - Master는 ItemReader를 통해 데이터를 읽고 청크 단위로 묶어서 Worker에게 보낸다.
    - Worker는 청크 데이터를 수신하여 ItemProcessor와 ItemWriter를 실행하고 처리 결과를 다시 Master에게 보낸다.
    - Master와 Worker가 보통 MQ로 통신하게 되기 때문에, 구축 비용이 높다.