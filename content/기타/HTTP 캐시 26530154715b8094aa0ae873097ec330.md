# HTTP 캐시

작성일: 2025년 9월 5일 오후 1:56
카테고리: Web

## Cache-Control

---

- HTTP에서는 `Cache-Control` 헤더를 활용하여 캐시를 사용할 수 있다.
- 매번 DB를 조회하고, 무거운 정보를 내려주는 것은 비용이 많이 들기 때문에 유용하다.
- 참고 : HTTP/1.0 시절에는 동일한 기능을 위해 `Expires`가 사용되었다.

### 작동 방식

1. 클라이언트가 서버에 HTTP 요청을 한다.
2. 서버는 HTTP 응답에 `Cache-Control` 헤더를 추가한다.
    - `no-store` / `no-cache` : 캐시를 사용하지 않을 때
    - `max-age=<초>` : 캐시를 사용할 때, 캐시를 사용할 시간을 지정한다.
    - 이외에도 여러가지가 존재한다. 해당 예시에서는 max-age가 설정되었다고 가정한다.
3. 클라이언트는 해당 응답을 캐싱해두고, 주어진 시간동안에 동일 요청에 대하여 캐시된 응답을 활용한다. (서버로 요청 X)
4. 주어진 시간이 모두 끝나면 다시 요청한다.

## ETag

---

- 캐시를 활용하는 방식을 최적화하는 헤더이다.
- 기존에는 캐시에 주어진 시간이 모두 끝나면 다시 요청해야 했다.
- 하지만 `ETag`를 통해서 서버는 304응답을 하고, 캐시를 다시 사용할 수 있다.

### 작동 방식

1. 서버의 최초 200 응답에 `ETag`값이 포함되어 온다.
2. 클라이언트는 주어진 시간이 모두 끝나고 다시 요청할 때, 해당 `ETag` 를 포함하여 요청한다. (`If-None-Match` 헤더)
3. 서버는 해당 ETag에 해당하는 데이터를 확인하고, 변경되지 않았음을 확인한다.
4. 변경되지 않았으므로 동일 응답을 다시 내려줄 필요가 없다. **304** 응답을 한다. (여기에 새로운 Cache-Control을 보통 포함한다.)
5. 클라이언트는 기존 캐시를 재활용해도 되었음을 확인했고, 새로운 시간동안 캐시를 다시 활용한다.

## Last-Modified

---

- 위 `ETag` 와 동일한 역할을 수행한다.
- 단, `ETag` 는 엔티티 태그로, 특정 문자열이 오고, `Last-Modified` 는 시간이 온다.

## 정리

---

### 캐시 사용 X

1. 요청 → 전체응답
2. 요청 → 전체응답
3. 요청 → 전체응답
4. 요청 → 전체응답

### Cache-Control 사용

1. 요청 → 전체응답
2. 캐시사용
3. 요청 → 전체응답
4. 캐시사용

### Cache-Control + ETag/Last-Modified 사용

1. 요청 → 전체응답
2. 캐시사용
3. 요청 → 304응답
4. 캐시사용

## 기타 : Vary 헤더

---

- 브라우저는 기본적으로 `Http Method + URL` 를 기준으로 캐싱을 한다.
- 하지만 같은 `Method + URL` 이더라도, 응답이 달라지는 경우가 존재한다.
    - 응답 언어가 다른 경우
    - 응답 인코딩이 다른 경우
    - …
- 따라서 브라우저가 정확히 캐시를 사용하도록 하기 위해서는 `Http Method + URL + @` 를 통해 캐시를 찾도록 해야 한다.
- 이것이 `Vary` 헤더이다.
- `Vary: Accept-Encoding` : Accept-Encoding에 따라서도 캐시를 구분하라!