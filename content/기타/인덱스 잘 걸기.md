# 인덱스 잘 걸기

작성일: 2025년 10월 15일 오후 12:58

- DB의 인덱스는 쿼리를 빠르게 수행하도록 도와준다.
- 예시
    - `select * from user u where u.name = ? and u.gender = ?` 라는 쿼리에서 `name`에 인덱스가 없으면 테이블을 다 찾아보아야 한다. (full scan)
    - `name`, `gender` 에 인덱스가 걸려 있으면, 이를 기준으로 원하는 행의 주소를 빠르게 찾아낼 수 있다.
    - 그렇게 찾아낸 행의 주소를 통해 테이블을 가져오면 되므로, 검색이 훨씬 빨라진다.

## 인덱스 잘 거는 법 1 : 카디널리티가 높은 칼럼에 걸기

- 인덱스는 b-tree 형식으로 저장된다. (InnoDB 기준)
    
    ![image.png](%EC%9D%B8%EB%8D%B1%EC%8A%A4%20%EC%9E%98%20%EA%B1%B8%EA%B8%B0%2028d30154715b8018a60aea53cfe2a185/image.png)
    
- 따라서 검색의 depth가 줄어들기 위해서는 **관련없는 행을 많이 제거해내야 한다.**
- 위 예시에서 `name` 의 경우, 동명이인인 경우는 상당히 적으므로 인덱스의 기준이 되기에 좋다.
    - 10만 데이터 → name으로 인덱스 스캔 → 5개 발견 → 5개 중에서 gender 테이블 스캔 → 3개 응답
    - 인덱스로 걸러낸게 10만개 수준, 테이블로 걸러낸게 2개 수준 : 인덱스를 잘 사용했다.
- 하지만 `gender` 의 경우, 절반은 중복이므로 관련없는 행이 너무 많이 검색되고, 결국 테이블 수준에서의 스캔이 늘어나게 된다.
    - 10만 데이터 → gender로 인덱스 스캔 → 5만개 발견 → 5만개 중에서 name 테이블 스캔 → 3개 응답
    - 인덱스로 걸러낸게 5만개 수준, 테이블로 걸러낸게 5만개 수준 : 인덱스를 잘못 사용했다.
- 즉, 칼럼의 중복여부가 중요한데, 어려운 말로 `‘카디널리티(고유 수치)’가 높은 칼럼을 선택해야 한다.` 라고 한다.

## 인덱스 잘 거는 법 2 : 카디널리티가 높은 순서대로 걸기

- 사실 위의 예시에서 카디널리티가 극도록 높은 것은 `name, gender` 두 칼럼 모두를 기준으로 거는 것이다. (복합 인덱스)
    - 10만 데이터 → name, gender로 인덱스 스캔 → 3개 발견 → 3개 테이블 검색 → 3개 응답
- 복합 인덱스의 경우에는 첫번째 칼럼을 기준으로 정렬하고, 만약 같은 경우에는 두번째 칼럼을 기준으로 정렬하는 식으로 구성된다. 즉 **순서가 중요하다.**
- 그러면 `name, gender` 와 `gender, name` 중에 무엇이 좋을까?
- 카디널리티가 높은 `name` 을 먼저 걸어주는 것이 좋다.
    - 카디널리티(고유 수치)가 높을 수록 b-tree의 초반 분기가 많아지고, 따라서 검색의 depth가 줄어든다.

## 인덱스 잘 거는 법 3 : where절을 넘어서

- 지금까지의 인덱스 설명은 where 절에 국한되었다.
- **하지만, where 절의 모든 칼럼이 인덱스에 포함되어 있다면,** 추가적으로 select 절이나 orderby 절의 칼럼도 인덱스의 기준이 될 수 있다.
    - orderby : 인덱스는 정렬되기 때문에, 인덱스 순서대로 읽으면 된다. (따로 테이블 수준의 정렬이 필요 없어진다.)
    - select : 인덱스만으로 모든 필터링이 가능한 경우에, 굳이 테이블을 보지 않고도 인덱스에서 select절을 채울 수 있으면 테이블을 아예 보지 않아도 된다. (커버링 인덱스)

### orderby

- `select * from user u where u.name = ? and u.gender = ? order by u.number` 라는 쿼리에서 인덱스가 `name, gender, number` 순서로 걸려 있으면, 앞선 두 칼럼으로 필터링을 거친 후의 데이터는 number 순서대로 정렬되어 있게 된다.
- 단, 인덱스가 `name, number, gender` 처럼 where 절이 먼저 선행되지 않으면 필터링이 다 끝나지 못한 상태에서 정렬되므로, 인덱스를 잘 활용하지 못하게 된다.
- 또한 인덱스가 `name, number` 처럼 where 절이 불충분해도 위와 같은 이유로 잘 활용하지 못한다.

### select

- `select u.id, u.number where u.name = ? and u.gender = ?` 라는 쿼리에서 인덱스가 `name, gender, id, number` 순서로 걸려 있으면, 앞선 두 칼럼으로 필터링을 거친 후의 데이터는 select 절의 모든  칼럼을 포함하게 된다. 이 경우 테이블을 굳이 보지 않아도 index 만으로도 쿼리 수행이 가능한 것이다.
- 이때 id와 number 칼럼의 순서는 중요하지 않다.
- orderby와 동일하게 where 절이 선행되지 않거나, where 절이 불충분하면 의미없다.
- 또한 select 절의 모든 칼럼을 포함하지 않아도 결국 테이블을 보게 되므로 의미없다.

(이외에도 group by, distinct, union 등의 여러 절의 칼럼들이 기준이 될 수 있다.)

## 정리

- 인덱스를 통해 쿼리 속도를 향상시킬 수 있다.
- 복합 인덱스에 거는 칼럼은 다음과 같은 순서를 따라야 한다.
    - where 절에 들어가는 칼럼들을 가장 우선 배치한다.
        - 그 안에서는 카디널리티 순으로 정렬한다.
    - where절을 모두 쓴 이후에는 orderby 절에 들어가는 칼럼을 쓸 수 있다.
    - where절을 모두 쓴 이후에는 select 절에 들어가는 칼럼을 쓸 수 있다.
        - 쓸거면 다 써야 한다.