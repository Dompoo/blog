# 1. 각 기능별 최대 TPS 구하기

- 대한민국 타겟
- 대한민국 러너 총인원수는 1000만명
- 따라서 최종 예상 사용자는 1000만명
- 점진적으로 늘려갈 예정이라, 현재 목표 사용자는 1만명
- 수도권을 일단 타겟으로 하므로 5000명

---

러너들은 평균 2일에 1번 뛴다. 해당 날짜에 뛰는 비율은 50%

러너들은 새벽에 가장 많이 뛴다.(여름기준) 새벽 5~5시반 사용자 40%

~~러너들이 N번 뛰면 1번 코스를 새로 찾을 것이다. 이 비율은 조사가 필요하므로 일단 넘어간다.~~

이를 바탕으로 계산하면 30분 동안 매초 평균 사용자 수는 `0.556` 이다. ( (5000 * 50 / 100 * 40 / 100) / (30 * 60) )

---

### 주변 코스 조회 기능

각 사용자마다 다음 유스케이스가 존재한다.

- 뛰러 나가서 코스를 찾는 경우 : 1페이지 중에 찾거나, 1번 정도 더 조회할 수 있음 → 1.33
- 집 가는 길에 찾고(2회), 집에 도착해서 한번 더 찾는 경우(1회) → 3.33

= 2.83번 사용

매초 `1.602` 트래픽 발생 (0.556 * 2.83)

### 자체 길찾기 기능

- 주변 코스 조회이기 때문에, 대부분의 길을 이미 알고 있을 것이라 가정 따라서 5개의 코스 중에 1개의 코스 정도까지 길찾기 기능 사용
- 5명 중 4명이 자체 길찾기 사용

매초 `0.089` 트래픽 발생 (0.556 * 0.2 * 0.8)

### 가장 가까운 좌표 구하기 기능 (네이버/카카오 길찾기)

- 주변 코스 조회이기 때문에, 대부분의 길을 이미 알고 있을 것이라 가정 따라서 5개의 코스 중에 1개의 코스 정도까지 길찾기 기능 사용
- 5명 중 1명이 타사 길찾기 사용

매초 `0.022` 트래픽 발생 (0.556 * 0.2 * 0.2)

### 코스 즐겨찾기 조회 기능

- 각 사용자가 코스를 조회하기 전에 1번씩은 사용한다고 가정, 추가적으로 2개의 신규 코스를 뛰면 1개는 추가할 것이라고 가정 → 1.5

매초 `0.804` 트래픽 발생 (0.556 * 1.5)

---

## 테스트

### 목표 수치

- 주변 코스 조회 기능 : 1500ms
- 자체 길찾기 기능 : 1800ms
- 가장 가까운 좌표 구하기 기능 : 800ms
- 코스 즐겨찾기 조회 기능 : 1000ms

### 스크립트

```java
import http from 'k6/http';
import { sleep, check } from 'k6';
import { Rate } from 'k6/metrics';
import { SharedArray } from 'k6/data';

// 커스텀 메트릭 정의
const errorRate = new Rate('errors');

// 테스트 설정
export const options = {
  scenarios: {
    // 실제 새벽 피크 시간대 시뮬레이션 (30분)
    peak_load: {
      executor: 'ramping-arrival-rate',
      startRate: 0,
      timeUnit: '1s',
      preAllocatedVUs: 50,
      maxVUs: 200,
      stages: [
        { duration: '2m', target: 3 },   // 워밍업: 초당 3 요청까지
        { duration: '6m', target: 3 },  // 피크 유지: 초당 약 3 요청 (2.517 TPS 목표)
        { duration: '2m', target: 0 },   // 쿨다운
      ],
    },
  },
  thresholds: {
    http_req_duration: ['p(95)<1000', 'p(99)<1500'],
    http_req_failed: ['rate<0.01'],
    errors: ['rate<0.01'],
  },
};

// 환경 설정
const BASE_URL = __ENV.BASE_URL;

// API 엔드포인트
const ENDPOINTS = {
  nearByCourses: '/courses',
  routeFinding: '/courses/{id}/route',
  nearestCoordinate: '/courses/{id}/closest-coordinate',
  favoriteCourses: '/courses/favorites',
};

// 사용자 행동 가중치 (계산된 비율 기반)
const ACTION_WEIGHTS = {
  nearByCourses: 1.602,    // 63.6% 비중
  favoriteCourses: 0.804,  // 31.9% 비중
  routeFinding: 0.089,     // 3.5% 비중
  nearestCoordinate: 0.022 // 0.9% 비중
};

// 총 가중치 계산
const totalWeight = Object.values(ACTION_WEIGHTS).reduce((sum, weight) => sum + weight, 0);

// 랜덤 좌표 생성 (서울 수도권 기준)
function getRandomSeoulCoordinate() {
  return {
    latitude: 37.4 + Math.random() * 0.6,   // 37.4 ~ 38.0
    longitude: 126.8 + Math.random() * 0.6, // 126.8 ~ 127.4
  };
}

// 액션 선택 함수 (가중치 기반)
function selectAction() {
  const rand = Math.random() * totalWeight;
  let cumulative = 0;
  
  for (const [action, weight] of Object.entries(ACTION_WEIGHTS)) {
    cumulative += weight;
    if (rand <= cumulative) {
      return action;
    }
  }
  return 'nearByCourses'; // fallback
}

const courseData = JSON.parse(open('./course-ids.json'));
const COURSE_IDS = courseData.courseIds;

// 각 API 호출 함수
function callNearByCourses() {
  const mapCoord = getRandomSeoulCoordinate();
  const userCoord = getRandomSeoulCoordinate();
  const scope = 5000;
  const page = 0;
  
  const url = `${BASE_URL}${ENDPOINTS.nearByCourses}?mapLat=${mapCoord.latitude}&mapLng=${mapCoord.longitude}&userLat=${userCoord.latitude}&userLng=${userCoord.longitude}&scope=${scope}&page=${page}`;
  
  const res = http.get(url, {
    tags: { name: 'NearByCourses' },
  });
  
  check(res, {
    '주변 코스 조회 성공': (r) => r.status === 200,
    '주변 코스 조회 응답시간 < 1500ms': (r) => r.timings.duration < 1500,
  });
  
  if (res.status !== 200) {
    errorRate.add(1);
  }
  
  return res;
}

function callRouteFinding(courseId) {
  const coord = getRandomSeoulCoordinate();
  const id = courseId || COURSE_IDS[Math.floor(Math.random() * COURSE_IDS.length)];
  const url = `${BASE_URL}/courses/${id}/route?startLat=${coord.latitude}&startLng=${coord.longitude}`;
  
  const res = http.get(url, {
    tags: { name: 'RouteFinding' },
  });
  
  check(res, {
    '길찾기 성공': (r) => r.status === 200,
    '길찾기 응답시간 < 1800ms': (r) => r.timings.duration < 1800,
  });
  
  if (res.status !== 200) {
    errorRate.add(1);
  }
  
  return res;
}

// 네이버, 카카오 지도
function callNearestCoordinate(courseId) {
  const coord = getRandomSeoulCoordinate();
  const id = courseId || COURSE_IDS[Math.floor(Math.random() * COURSE_IDS.length)];
  const url = `${BASE_URL}/courses/${id}/closest-coordinate?lat=${coord.latitude}&lng=${coord.longitude}`;
  
  const res = http.get(url, {
    tags: { name: 'NearestCoordinate' },
  });
  
  check(res, {
    '가장 가까운 좌표 조회 성공': (r) => r.status === 200,
    '가장 가까운 좌표 응답시간 < 800ms': (r) => r.timings.duration < 800,
  });
  
  if (res.status !== 200) {
    errorRate.add(1);
  }
  
  return res;
}

function callFavoriteCourses() {
  // 랜덤으로 3~5개의 즐겨찾기 코스 조회
  const count = Math.floor(Math.random() * 3) + 3;
  const selectedIds = [];
  for (let i = 0; i < count; i++) {
    selectedIds.push(COURSE_IDS[Math.floor(Math.random() * COURSE_IDS.length)]);
  }
  
  // courseIds를 쿼리 파라미터로 여러 개 전달
  const params = "courseIds=" + selectedIds.map(id => `${id}`).join(',');
  const url = `${BASE_URL}${ENDPOINTS.favoriteCourses}?${params}`;
  
  const res = http.get(url, {
    tags: { name: 'FavoriteCourses' },
  });
  
  check(res, {
    '즐겨찾기 조회 성공': (r) => r.status === 200,
    '즐겨찾기 조회 응답시간 < 1000ms': (r) => r.timings.duration < 1000,
  });
  
  if (res.status !== 200) {
    errorRate.add(1);
  }
  
  return res;
}

// 메인 시나리오
export default function () {
  // 가중치 기반 액션 선택
  const action = selectAction();
  
  switch (action) {
    case 'nearByCourses':
      callNearByCourses();
      break;
      
    case 'routeFinding':
      callRouteFinding();
      break;
      
    case 'nearestCoordinate':
      callNearestCoordinate();
      break;
      
    case 'favoriteCourses':
      callFavoriteCourses();
      break;
  }
  
  // 실제 사용자 행동 시뮬레이션을 위한 약간의 대기
  sleep(Math.random() * 2 + 1); // 1~3초 랜덤 대기
}

// 테스트 시작/종료 시 실행
export function setup() {
  console.log('=== 성능 테스트 시작 ===');
  console.log(`목표 TPS: ${totalWeight.toFixed(3)}`);
  console.log('기능별 예상 TPS:');
  console.log(`  - 주변 코스 조회: ${ACTION_WEIGHTS.nearByCourses}`);
  console.log(`  - 즐겨찾기 조회: ${ACTION_WEIGHTS.favoriteCourses}`);
  console.log(`  - 길찾기: ${ACTION_WEIGHTS.routeFinding}`);
  console.log(`  - 가장 가까운 좌표: ${ACTION_WEIGHTS.nearestCoordinate}`);
}

export function teardown(data) {
  console.log('=== 성능 테스트 종료 ===');
}
```

### 실행

```bash
BASE_URL=http://3.39.229.235 k6 run test.js
```

```bash
K6_WEB_DASHBOARD=true BASE_URL=http://3.39.229.235 k6 run test.js
//대시보드로 결과 확인 가능한 설정
```

### 테스트 결과

```java
  █ TOTAL RESULTS 

    checks_total.......: 2880   4.777994/s
    checks_succeeded...: 99.02% 2852 out of 2880
    checks_failed......: 0.97%  28 out of 2880

    ✓ 즐겨찾기 조회 성공
    ✗ 즐겨찾기 조회 응답시간 < 1000ms
      ↳  98% — ✓ 452 / ✗ 8
    ✓ 주변 코스 조회 성공
    ✗ 주변 코스 조회 응답시간 < 1500ms
      ↳  98% — ✓ 910 / ✗ 18
    ✓ 길찾기 성공
    ✗ 길찾기 응답시간 < 1800ms
      ↳  95% — ✓ 43 / ✗ 2
    ✓ 가장 가까운 좌표 조회 성공
    ✓ 가장 가까운 좌표 응답시간 < 800ms

    CUSTOM
    errors.........................: 0.00%  0 out of 0

    HTTP
    http_req_duration..............: avg=237.35ms min=10.54ms med=74.96ms max=6.2s  p(90)=722.55ms p(95)=1.01s
    http_req_failed................: 0.00%  0 out of 1440
```

### 테스트 결과 분석

- 모든 요청이 정상 응답 ✅
    
- 응답 시간
    
    - 평균 237.35ms
    - 최대 6.2s
    - p(90)=722.55ms
    - p(95)=1.01s
- `주변 코스 조회` API는 2%가 1500ms 이상의 응답을 받음
    
- `즐겨찾기 코스 조회` API는 2%가 1000ms 이상의 응답을 받음
    
- `길찾기` API는 5%가 1800ms 이상의 응답을 받음
    
- `가장 가까운 좌표` API는 모두 800ms 이하의 응답 성공
    
- **✅ 결론 : 목표 TPS에도 정상적으로 동작함!**
    
- 메모리 사용량
    
    ![image.png](attachment:42b4521d-d544-4927-8dd9-53593f1fcecf:image.png)
    

# **2. 무중단 배포 구현**

- docker hub 이슈로 내일하기

# **3. 확장성 있는 아키텍처 설계**

사용자가 늘어날때마다 병목이 될 부분

- 5000명(현재) : 문제 없음

### OSRM 서버

- OSRM 서버가 어느정도의 트래픽을 견딜 수 있을지 확인이 되지 않음.
- 추후 부하테스트에서 문제가 발생되면 다음 태스크 실행

1. 컴퓨팅 최적화 인스턴스 타입으로 이전
2. 메모리가 여유있는 인스턴스 타입으로 이전