## DDD 등장 배경

- 애플리케이션이 복잡해졌다.
- 복잡해지며 개발자와 전문가 사이의 의사소통 문제가 발생했다.

## DDD 등장

- 도메인에 집중하여 복잡성을 통제
    - 유지보수성과 확장성 또한 향상
- 공통 언어를 통해 의사소통 문제 완화

# DDD 개념들

## 범위와 경계

- **Aggregate**
    - 하나 이상의 엔티티와 값 객체를 포함하는 **일관성 경계 단위**.
    - 트랜잭션은 애그리거트 단위로 처리되며, 외부에서는 **Aggregate Root**를 통해서만 접근 가능.
- **Bounded Context**
    - **도메인 모델의 의미가 명확하게 정의된 경계**.
    - 같은 용어라도 컨텍스트가 다르면 **다른 의미**를 가질 수 있음.
    - (예: `Order`가 쇼핑몰과 물류 시스템에서 다르게 쓰일 수 있음)

## 객체

- **Entity**
    - **고유한 식별자(ID)**를 통해 동일성을 유지하는 객체.
    - 상태가 바뀌어도 동일한 것으로 간주됨.
- **Value Object**
    - 식별자가 없으며, **값 자체로 동일성**을 판단하는 객체.
    - 보통 불변 객체로 설계하며, 변경 시 새로 생성.
- **Aggregate Root**
    - 애그리거트의 **진입점이 되는 엔티티**.
    - 외부는 루트를 통해서만 애그리거트 내부에 접근할 수 있음.
    - 내부 구성 요소는 직접적으로 접근하거나 조작하지 않음.
- **Domain Service**
    - 특정 엔티티에 속하지 않는 **비즈니스 로직**을 담당.
    - 여러 엔티티나 값 객체에 걸친 도메인 규칙을 구현.
    - 순수한 도메인 로직이므로 **상태(state)를 갖지 않음**.
- **Repository**
    - **애그리거트 루트 단위**로 저장하고 조회하는 객체.
    - 영속성 기술(JPA 등)을 숨기고 도메인 모델에 맞는 인터페이스 제공.

# DDD를 맛보고 든 생각