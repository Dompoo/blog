- **여러 데이터를 한번에 수정하거나 삭제하는 연산이다.**
- 스프링에서는 `@Modifying` 애노태이션과 JPQL로 구현한다.

```java
@Modifying
@Query("update Member m set m.age = m.age + 1 where m.age >= :age")
int bulkAgePlus(@Param("age") int age);

@Modifying
@Query("delete from Member m where m.age <= :age")
int bulkDeleteByAgeUnder(@Param("age") int age);
```

- 한번에 SQL로 처리하므로 효율적이다.
- 하지만, flush 이후 바로 SQL로 나가므로, 벌크 연산 이후에는 영속성 컨텍스트와의 불일치가 발생할 수 있다.
    - 따라서 기본적으로 트랜잭션의 가장 처음/끝에 사용해야 한다.
    - `em.clear()` 를 통해 수동으로 영속성 컨텍스트를 비우는 것으로 해결 가능
    - `clearAutomatically = true` 를 통해 **실행 후에 영속성 컨텍스트를 비우도록 할 수 있다.**
    - `flushAutomatically = true` 를 통해 **실행 전에 영속성 컨텍스트를 flush 하도록 할 수 있다.**

![[벌크연산_image.png]]

## 최적화

```java
@QueryHints({
    @QueryHint(name = "hibernate.jdbc.batch_size", value = "100"),
    @QueryHint(name = "hibernate.order_inserts", value = "true")
})
```

- 위와 같은 방식으로 배치 연산을 최적화 해줄 수 있다.
    - `hibernate.jdbc.batch_size` : 한번의 Round Trip에 여러 SQL을 묶어서 전달한다. → 네트워크 부하 감소
    - `hibernate.order_inserts` : 동일 테이블에 대한 여러 INSERT 문을 그룹화하여 실행한다. → 인덱스 부하 감소
- `@BatchSize` 는 지연 로딩시의 SELECT 최적화(IN절 활용), `hibernate.jdbc.batch_size` 는 DML 시의 최적화이다.