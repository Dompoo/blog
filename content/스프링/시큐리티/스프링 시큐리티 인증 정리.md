## 주요 컴포넌트

- `Authentication`
    - 인증 객체
    - 사용자 정보와 인증 여부를 포함한다.
    - 인증 전체가 사용자 정보만 담은 `Authentication` 객체를 인증 주체가 인증해서 응답하는 흐름이다.
- `SecurityContextHolder`
    - 인증 정보를 담는 객체이다.
    - 인증이 완료된 `Authentication` 을 여기에 담기까지 해야 인증이 끝나는 것이다.
    - 해당 인증 정보를 어디까지 담고 있을지 설정할 수 있다.
        - ThreadLocal로 저장한다. (기본값)
        - 자식스레드에도 공유한다.
        - 모든 요청끼리 공유한다.
- `SecurityContextRepository`
    - 인증 정보를 저장하는 객체이다.
    - `SecurityContextHolder` 는 스레드 수준에서, `SecurityContextRepository` 는 저장소 수준에서 저장한다고 이해하면 된다.
    - 세션 기반 인증 처럼 요청 간에 인증 정보가 저장될 필요가 있을 때 사용한다.
- `FilterChain`
    - 스프링 시큐리티의 수많은 기능들은 필터를 통해서 동작한다.
    - 해당 필터들은 실제 서블릿에 등록되는 필터들은 아니며, 실제 등록된 필터는 `DelegatingFilterProxy` 하나 뿐이다.
    - `DelegatingFilterProxy` 가 요청을 가로채 `FilterChain` 으로 넘겨주고, 여러 필터들을 지나며 기능들이 실행된다.
    - 예를 들어, `UsernamePasswordAuthenticationFilter` 는 form 형식으로 넘어온 username/password를 통해 인증을 시도한다.
- `AuthenticationManager`
    - 인증을 책임지는 주체이다.
    - 여러 필터들에 의해 호출되며, `Authentication` 객체를 받아서 `AuthenticationProvider` 에게 넘겨준다.
    - 실제로 인증은 `AuthenticationProvider` 들에 의해 수행된다.
- `AuthenticationProvider`
    - 인증을 수행하는 실제 객체이다.
    - 자신이 원하는 형식의 `Authentication` 객체를 받아서 인증을 수행한다.
    - 예를 들어, `DaoAuthenticationProvider` 는 DB에 접근하여 인증을 수행한다.
- `UserDetailsService`
    - 사용자 이름을 통해 `UserDetails` 를 찾아서 응답하는 객체이다.
    - `DaoAuthenticationProvider` 등에 의해 사용된다.

## 인증 흐름 (6.5.0 기준)

- 표준 서블릿 필터 구현체 `DelegatingFilterProxy` 를 통해서 security filter chain이 시작된다.
- `filter chain`에 등록된 여러 필터들이 인증을 시도한다.
    - 각 필터들은 아직 인증되지 않았고, 요청 형식이 자신의 것과 동일하다면 인증을 시도한다.
    - **인증에 성공하면** `SecurityContextHolder` **에 인증 정보를 저장한다.**
    - 여기서는 `UsernamePasswordAuthenticationFilter`가 요청을 가로챘다고 가정하자.
- 예시 인증 필터 동작 (`UsernamePasswordAuthenticationFilter`)
    - 해당 필터는 아직 `SecurityContextHolder` 에 인증 정보가 없고, 요청 형식이 자신의 것과 동일하기 때문에 인증을 시도한다.
    - `Authentication` 객체를 생성한다. (구현체는 일반적으로 `UsernamePasswordAuthenticationToken`)
    - `AuthenticationManager` 에게 인증을 위임한다.
    - `AuthenticationManager` 는 전달받은 `Authentication` 객체를 `AuthenticationProvider` 들에게 처리하도록 요청한다.
    - 처리 가능한 `AuthenticationProvider` (구현체는 `DaoAuthenticationProvider`라고 가정)가 실제 인증 처리를 시도한다.
    - `UserDetailsService` 를 통해 username에 해당하는 사용자 정보(`UserDetails`)를 찾고, `PasswordEncoder`를 통해 비밀번호를 검증한다.
    - 인증에 성공하면 인증 성공 상태의 `Authentication` 가 기존 필터까지 반환된다.
- `UsernamePasswordAuthenticationFilter` 는 인증 성공 상태를 보고 `SecurityContextHolder` 에 `Authentication` 객체를 저장한다. (인증 완료)
- 인증 성공 후, 이후의 모든 요청은 `SecurityContextHolder` 를 통해 사용자 정보에 접근해볼 수 있다.

## 인증 흐름에서의 주요 객체

- `UsernamePasswordAuthenticationFilter` : 로그인 요청을 가로채 `AuthenticationManager` 에게 인증 흐름 위임
- `Authentication` : 사용자 인증정보가 존재하는 객체
- `AuthenticationManager` : 실제 인증을 `AuthenticationProvider`에게 위임하는 관리자
- `AuthenticationProvider` : 실제 인증을 처리하는 객체
- `UserDetailsService` : 사용자 저장소에서 사용자 정보(`UserDetails`)를 조회 및 반환
- `UserDetails` : 사용자 정보 (비밀번호, 권한, 계정 상태 등)
- `SecurityContextHolder` : 인증된 `Authentication` 을 들고 있는 객체
    - 주의점 : 세션 기반과 토큰 기반의 SecurityContextHolder의 역할이 약간 다르다.
    - 세션 기반에서는 SecurityContext가 세션간 유지된다.
    - 토큰 기반에서는 SecurityContext가 단일 HTTP 요청에서만 유지된다.

## 토큰 방식으로 인증 구현해보기

> 토큰 방식이므로 인증 정보를 세션에 저장하면 안된다.
세션 생성 정책을 STATELESS로 설정하자.
> 
- 초기 인증 (로그인)
    - 사용자가 `/login` URI로 로그인 요청을 보낸다.
    - 아이디/비밀번호 인증 후 `JwtUtil` 등으로 토큰을 만들어 응답한다.
- 인증
    - 구현한 `JwtAuthenticationFilter` 가 요청을 가로챈다.
    - Authorization 헤더에서 토큰을 추출하여 토큰 유효성 검사를 진행한다.
    - 인증되지 않은 상태의 `Authentication` 을 만든다.
    - `AuthenticationManager` 에게 인증을 위임한다.
    - `AuthenticationManager` 는 구현한 `JwtAuthenticationProvider`에게 인증을 위임한다.
    - `JwtAuthenticationProvider` 가 `JwtUtil` 과 `UserDetailsService` 를 통해서 실제 인증 처리를 진행한다.
    - 그 응답으로 인증된 상태의 `Authentication` 를 받는다.
    - `SecurityContextHolder` 에 해당 `Authentication` 을 설정한다.
- 구현이 필요한 것들
    - `JwtAuthenticationFilter` : `OncePerRequestFilter` 구현
    - `JwtAuthenticationProvider`
    - `JwtUtil`
    - `UserDetailsService`

## 세션 방식으로 인증 구현해보기

- 초기 인증 (로그인)
    - 사용자가 `/login` URI로 로그인 요청을 보낸다.
    - 구현한 `JsonAuthenticationFilter` 가 요청을 가로챈다.
    - `RequestBody` 에서 아이디/비밀번호를 추출한다.
    - 해당 정보로 인증되지 않은 상태의 `Authentication` 을 만든다.
    - `AuthenticationManager` 에게 인증을 위임한다.
    - `DaoAuthenticationProvider` 가 `UserDetailsService` 와 `PasswordEncoder` 를 통해서 실제 인증 처리를 진행한다.
    - 최종적으로 인증 프로세스가 완료되고, 필터와 함께 구성된 `AuthenticationSuccessHandler` 를 호출한다.
    - `AuthenticationSuccessHandler` 는 `SecurityContextHolder` 에 `Authentication`을 설정한다.
    - 또한 세션을 저장하기 위해 `SecurityContextRepository` 에도 해당 정보를 저장한다.
- 인증
    - `SecurityContextPersistenceFilter` 가 요청에 포함된 쿠키를 읽어, 해당 세션 ID에 해당하는 `HttpSession` 을 세션 저장소에서 찾는다.
    - `HttpSession` 이 유효하고, `SecurityContext` 가 설정되어 있다면, 기존 `SecurityContext` 를 `SecurityContextHolder` 에 로드한다.
- 구현이 필요한 것들
    - `JsonAuthenticationFilter` : `AbstractAuthenticationProcessingFilter` 또는 `UsernamePasswordAuthenticationFilter` 구현
    - `UserDetailsService`
    - `JsonAuthenticationSucessHandler`