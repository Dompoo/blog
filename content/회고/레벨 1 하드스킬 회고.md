# 로또 미션

---

첫 미션, 첫 페어프로그래밍, 1주 라는 환경 속에서 로또 미션은 정신없게 흘러갔다. 1주 동안 가장 많이 느낀 것은 **DIP와 테스트 가능성**이었다.

## 의존성 역전과 테스트가능성

> 먼저 테스트를 짠다고 하면, 요구사항 달성에 가장 중요한 부분인 **도메인**을 ****테스트하고 싶을 것이다. 하지만, 그런 도메인이 어딘가에 의존하고 있다면 어떻게 해야 할까?

로또 미션에서 내 도메인은 **랜덤 번호 뽑기** 기능에 의존하고 있었다. `Lotto` 객체는 랜덤 번호 뽑기 기능을 통해 랜덤으로 생성될 수 있어야만 했다. 문제는 테스트에서 발생한다. 랜덤성을 통제할 수 없기 때문이다.

```java
@Test
void 로또를_구입한다() {
		Lotto result = Lotto.purchase();
		
		assertThat(result).extracting("numbers")
		            .isEqualTo(List.of(1, 2, 3, 4, 5, 6)); // ???
}
```

랜덤으로 번호를 뽑기 때문에 로또 번호가 제대로 설정되었는지 확인하기 어렵다. 랜덤성을 통제할 수 있다면 번호가 어떤 값으로 세팅될지도 알 수 있다.

이를 달성하기 위해 나는 의존성을 역전시켰다. `Lotto` 객체가 더이상 랜덤성에 의존하는 것이 아니라, 인터페이스에 의존하도록 한 것이다.

```java
public interface NumberPicker {   
    List<Integer> pickUnique(int start, int end, int count);
}

public class Lotto {
		// ...
		
		public static Lotto purchase(NumberPicker numberPicker) {
		    List<Integer> numbers = numberPicker.pickUnique(START_NUMBER, END_NUMBER, NUMBER_COUNT);
		    return new Lotto(numbers);
		}
}
```

실제 프로덕션 코드에서는 랜덤으로 번호를 뽑는 구현체를 통해 생성되도록 하고, 테스트에서는 정해진 값으로 번호를 뽑는 객체를 사용해볼 수 있다. 그러면 테스트는 아래와 같이 작성된다.

```java
@Test
void 로또를_구입한다() {
    NumberPicker numberPicker = new StaticNumberPicker(List.of(
        List.of(1, 2, 3, 4, 5, 6)
    ));

    Lotto result = Lotto.purchase(numberPicker);

    assertThat(result).extracting("numbers")
        .isEqualTo(List.of(1, 2, 3, 4, 5, 6));
}
```

이런 방법은 여러 곳에서 쓰일 수 있다. `InputView`, `OutputView` 처럼 입출력에 해당하는 개념, 랜덤성 등에 사용하여 테스트가능성을 높일 수 있다.

## 현재 위 방법에 대한 생각

하지만 위 방식에 대해 현재는 회의적이다. 의존성 역전을 통해 테스트가 가능해진 것은 맞지만 **애초에 테스트할 필요가 있던 것인가?** 아래 테스트정도면 충분하지 않았을까?

```java
@Test
void 로또를_구입한다.() {
		assertThatCode(() -> Lotto.purchase()).doesNotThrowAnyException();
}
```

해당 객체를 사용하는 입장에서 **정확히 뽑은 그 랜덤값으로 내부값이 세팅되길 바랬을까?** 그냥 적당히 6자리 수를 뽑기만 하면 되는 것 아니었을까?

즉 레벨 1 때 작성한 테스트는 구현세부사항에 너무 가깝다는 것이다. 만약 뽑는 방법이 바뀌어서 3개를 뽑고 3개를 버린 후에 나머지 3개를 뽑는다면? 로또 번호가 7개가 된다면? 테스트는 실패한다.

편의점에서 ‘자동이요’ 라는 말을 하며 로또를 구매하는 사람들이 과연 그 자동기계가 어떻게 동작하는지 궁금할까? 그냥 로또 종이를 받고 싶어한다. 그런 관점에서 테스트를 바라볼 필요가 있다고 생각한다.

# 출석 미션

---

출석 미션에서는 기술적으로 느낀 것이 많았다. 첫번째로 **정적 팩터리 메서드의 장점**과 두번째로 **DTO의 장점**, 그리고 **TDD**이다.

## 정적 팩터리 메서드의 장점

정적 팩터리 메서드는 왜 써야 할까? 그냥 생성자 오버로딩을 여러가지 생성방식을 두면 해결되는 것도 있는데, 진짜 장점이 뭘까?

```java
public class Attendance {
    
    private final AttendanceDate attendDate;
    private final AttendanceTime attendTime;
    private final AttendanceStatus status;
    
    // 기본 생성자
    private Attendance(
            final AttendanceDate attendDate,
            final AttendanceTime attendTime,
            final AttendanceStatus status
    ) {
        this.attendDate = attendDate;
        this.attendTime = attendTime;
        this.status = status;
    }
    
    // 출석한 경우의 생성자
    public Attendance(final LocalDate attendDate, final LocalTime attendTime) {
		    this(
				    new AttendanceDate(attendDate),
				    new ShowAttendanceTime(attendTime),
				    AttendanceStatus.of(attendDate.getDayOfWeek(), attendTime)
		    );
    }

    // 출석하지 않았을 경우의 생성자
    public Attendance(final LocalDate attendDate) {
		    this(
				    new AttendanceDate(attendDate),
            new NoShowAttendanceTime(),
				    AttendanceStatus.결석
		    );
    }
}
```

위 코드도 그럭저럭 잘 읽힌다. 주석 덕분인것 같기도 하다. 문제는 생성자가 너무 많을 때, **각 생성자가 어떤 역할을 하는지 이해하기 어렵다는 것이다.**

> 나는 가끔 크루들이 책임과 역할에 대해 고민할 때, 반 장난식으로 **클래스명을 바꿔보면 어떨까요? 메서드명을 바꿔보면 어떨까요?** 라고 말한다. 그만큼 이름을 중요하게 생각하는 것 같다.

나는 **생성자가 이름이 없기 때문에 발생하는 문제**라고 생각한다. 적절한 이름을 줄 수 있다면(주석처럼) 더 잘 읽히는 코드가 될 것이다. 이름을 줄 수 있는 가장 쉬운 방법은 메서드라고 생각하고, 그래서 정적 팩터리 메서드가 등장한다.

```java
public class Attendance {
    
    private final AttendanceDate attendDate;
    private final AttendanceTime attendTime;
    private final AttendanceStatus status;
    
    private Attendance(
            final AttendanceDate attendDate,
            final AttendanceTime attendTime,
            final AttendanceStatus status
    ) {
        this.attendDate = attendDate;
        this.attendTime = attendTime;
        this.status = status;
    }
    
    public static Attendance show(final LocalDate attendDate, final LocalTime attendTime) {
        return new Attendance(
            new AttendanceDate(attendDate),
            new ShowAttendanceTime(attendTime),
            AttendanceStatus.of(attendDate.getDayOfWeek(), attendTime)
        );
    }
    
    public static Attendance noShow(final LocalDate noShowDate) {
        return new Attendance(
            new AttendanceDate(noShowDate),
            new NoShowAttendanceTime(),
            AttendanceStatus.결석
        );
    }
}
```

`show()`, `noShow()` 라는 메서드명을 통해 각 기능의 역할을 더 잘 드러낼 수 있고, 더 읽기 좋은 코드가 된다.

### 그러면 정적 팩터리 메서드는 언제 사용하는게 좋을까?

정적 팩터리 메서드도 장점만 있는 것이 아니다. 정적 팩터리 메서드는 생성자가 아니기 때문에 생성한다는 역할을 드러내기 좀 더 어렵다는게 가장 큰 단점인 것 같다.

그래서 항상 사용하는 것이 아니라 생성 방법이 여러개 있고, 특히 몇몇은 특이한 방식일 때 사용하면 좋은 것 같다. 예를 들어 유저를 생성할 때, 로그인하지 않은 사용자를 위해 **익명 유저**를 만들어야 하는 상황이 잘 어울릴 것 같다.

### 또 다른 방법

정적 팩터리 메서드가 아니어도 이름을 줄 수 있는 방법은 많다.

- 파라미터를 하나로 묶은 이름있는 클래스 사용 - `NoShowAttendanceCreateRequest`
- 파라미터명을 적절하게 설정 - `noShowAttendDate`
- 짧고 명료한 주석
- 코드 자체로 역할을 잘 나타내기

정적 팩터리 메서드만이 정답이 아니다. 생성자의 단점을 이해하고 각 상황에서 최선의 방법을 고려하는 것이 중요하다!

## DTO는 왜 사용하는가?

프리코스와 로또 미션까지 나는 DTO를 반사적으로 사용했던 것 같다. 특히 반환값이 여러개인 상황이 있다고 생각했다. (ex. 출석을 수정하면 `기존 시간, 새로운 시간, 새로운 출석 상태` 를 반환한다.)

위 예시를 더 깊게 파고들어보면, 두가지 방법이 있다.

- 수정을 한다. 그 후에 getter를 통해 필요한 값을 가져온다.
- 수정을 하며 그 결과값을 DTO로 받아본다.

나는 지금껏 두번째 방식이 너무 당연하다고 생각했다. 하지만 크루들과 이야기해보니 **수정 기능에 반환값이 있을 필요가 없었다.** 두번째 방식이 당연하다고 느낀 것은 뷰가 있었기 때문이었고, 그래서 필요했기 때문이었다. 도메인 객체만을 띄워놓고 보면 추가/수정에는 반환값이 없고 필요한 값은 따로 조회하여 사용하는 것이 자연스럽다.

이런 상황들에서 DTO를 사용했고 getter를 지양했다.

### getter를 지양한 이유

나는 getter가 수동적인 객체를 만든다고 굳게 믿는다. 해당 객체에게 그냥 일을 시키면 되는데, 굳이 getter로 값을 꺼내서 외부에서 로직을 수행할 수 있기 때문이다.

getter를 추가한 나는 실수하지 않을 수 있지만 일주일 후의 나, 다른 개발자가 작성하는 것을 믿을 수 없기 때문이다. 따라서 DTO로 응답하는 것이 불필요한 getter를 줄이는 방법이라고 생각했다.

### DTO를 지양하고 싶었던 이유

하지만 DTO를 사용하는 방식도 썩 마음에 들지 않았다. DTO를 사용한다는 것은 도메인이 결국 클라이언트나 뷰에 의존하게 된다는 것을 의미하기 때문이었다.

무슨 방법을 선택해야 할까?

### 네오와의 커피챗

네오와 이야기하면서 DTO의 본래 목적을 고민하게 되었다.

원래 MVC 패턴에서 뷰가 도메인에 의존하는 것은 문제가 되지 않는다. 하지만 이럴 경우에 불변이 아닌 도메인은 뷰에서 상태가 수정될 위험이 존재한다.

이를 보호하는 것이 DTO이다. **도메인이 아니라, 필요한 값을 담은 값 덩어리를 통해 통신하도록 하여 도메인의 런타임 변경 위험성을 없애는 것**이다.

근데 DTO를 반환값으로 사용하게 되면 기존의 목적 자체에 위반되는 것이다. (뷰에 대한 의존성이 생기므로!) 따라서 DTO로 반환하는 것은 애초에 선택지에서 제거하고 고려하는게 좋다고 해주셨다.

## TDD

또 출석 미션에서 처음으로 TDD를 시작해서 직접 사용해보며 TDD에 대한 여러 고민을 할 수 있었다.

### TDD는 어디서부터 시작해야 하는가?

이와 관련해서도 많은 이야기를 했다. 해당 미션 후에도 테사모에서 이야기했던 주제이다.

일단 대중적으로 **탑다운, 바텀업** 두 방법이 대세였다.

- 탑다운 : 가장 상위 도메인부터 시작한다.
    - 장점
        - 시작할 부분이 명확하다.
        - 클라이언트 입장에서 필요한 도메인들을 하나씩 개발해나갈 수 있다.
        - 추후에 조립하는 개발 비용이 적다.
    - 단점
        - 어려운 기능의 경우 개발하기 막막할 수 있다.
        - 해당 기능을 개발하며 리팩터링할 부분이 많이 보인다.
        - 추후에 리팩터링하며 도메인의 Depth가 깊어지고 개발이 복잡해진다.
- 바텀업 : 상위 도메인에서 사용할 것 같은 하위 객체부터 시작한다.
    - 장점
        - 스탭이 매우 작아지고 쉬워진다.
        - 기능이 간단하기 때문에 시작하기 쉽다.
    - 단점
        - 추후에 여러 도메인들을 조립할 때 맞지 않는 부분들이 생겨 수정이 필요할 수 있다.
        - 하위 도메인 수정을 하나 하면 그 영향이 상위까지 전파된다.
        - 어떤 객체가 필요할지 설계할 시간이 많이 필요하다.

결론적으로 나는 둘 다 마음에 들지 않았다.

> 왜 마음에 들지 않았는가?

일단 내가 생각하는 TDD의 가장 큰 장점은 **개발하기 쉽다**는 데에 있다.

너무나도 어려울 것 같던 기능을 **일단 시작할 수 있다는 것,** 테스트는 복잡한 세부사항을 고려하지 않고 클라이언트 입장에서 원하는 것을 작성하면 되기 때문이다.

그런 부분에서 바텀업이 조금 더 내 추구미에 가까웠지만, 바텀업으로 개발하기 위해서는 설계 시간이 오래 걸린다. 어떤 객체들이 필요할지 미리 리스트업하고 각 객체의 기능들을 리스트업하는 과정은 지루하고 어렵다. 어렵기 때문에 결국 개발하기 어려워진다.

> 어떤 방식으로 진행할 것인가?

내가 정착한 방법은 **할 수 있는 것, 명료한 것부터 시작하는 것이다.**

로또 미션에서는 랜덤 번호로 로또를 생성하는 것, 출석 미션에서는 어떠한 날짜와 시간에 출석하고 노쇼하는 것이다. 이런 기능들은 요구사항을 달성하기 위해 너무나도 명료하게 필요하고, 어떤 테스트를 작성해야 하는지 생각하기 쉽다.

이런 기능들부터 시작함으로써 나는 **빠르게 시작할 수 있고**, 거의 실패하지 않는다.

### 얼만큼 조그만한 스탭으로 쪼개야 하는가?

TDD를 하면 `int add(int a, int b)` 같은 메서드도 테스트를 10개쯤 작성하여 완성해야 할 것 처럼 느껴진다. 매우 작은 스탭으로 시작하고 계속해서 작은 실패들을 맛보며 전진하는 느낌이다. 나에게는 군대에서의 `야간전술보행` 처럼 느껴졌는데, 앞을 조금씩 더듬으면서 전진하는 식이다.

근데 이러면 매우 간단한 기능도 개발하기 쉽지 않다. 벌써 구현을 다 아는데도 굳이굳이 테스트를 작성해야 하는 것이다. 이럴 필요가 있을까?

나는 이 부분에서 내가 생각하는 TDD의 장점을 다시 고려했다. 바로 **개발하기 쉽다**는 것이다.

TDD로 개발하면 쉬워야 한다. 그래서 내가 이미 구현을 다 아는 기능의 경우에는 Red에 머무는 시간이 매우 짧고, 그래서 굳이 수많은 실패를 맛볼 필요는 없다. 이럴 때는 보폭을 넓힐 필요가 있다. 보폭을 넓게 가져가다가 다시 막힐 때, ‘어떻게 개발해야하지?’ 라는 의문이 들 때 다시 보폭을 좁힌다. 몇번의 실패를 맛보며 다시 감을 잡는다.

포인트는 `Red` 에 머무르는 실제 시간을 비슷하게 맞추는 것이다. 모든 기능에 대하여 비슷하게 고민하고 비슷하게 실패하고 비슷한하게 헤매야 한다. `Red` 에 머무는 시간을 줄여서 개발의 안정성을 높이는 것이 TDD의 목표이기 때문에 보폭을 넓히고 좁히는 훈련을 해야 한다는 결론이다.

# 블랙잭 미션

---

블랙잭 미션에서는 한가지 주제에 대해 깊이 고민했다. - 상속과 조합이다.

## 상속과 조합 예시

두 방법 모두 기존 클래스에 기능을 추가할 때 사용한다.

블랙잭의 `BlackjackDeck` 을 구현해보자.

### Deck

```java
public class Deck {
	  
    // ...
    
    public Card draw() {
        return cards.poll();
    }
}
```

### 상속

```java
public final class BlackjackDeck extends Deck {
    
    public List<Card> handoutInitialCards() {
        return List.of(draw(), draw());
    }
}
```

위처럼 `Deck` 을 상속하는 `BlackjackDeck` 은 부모클래스의 모든 기능을 가지면서, 추가 기능을 정의한다.

### 조합

```java
public final class BlackjackDeck {
    
    private final Deck deck = new Deck();
    
    public List<Card> handoutInitialCards() {
        return List.of(draw(), draw());
    }
    
    public Card draw() {
        return deck.draw();
    }
}
```

조합을 사용하면 단순히 필드에 기존 클래스를 들고, 추가 기능을 정의하거나 기존 기능을 열어둘 수 있다.

## 상속과 조합 비교

상속은 먼저 눈에 보이는 장점이 있다. **다형성을 활용할 수 있다.** `Deck` 을 상속했기 때문에, `Deck` 이 들어가는 곳이라면 `BlackjackDeck` 도 들어갈 수 있다. 조합은 이것이 불가능하다.

조합은 **모든 기능이 한 객체에 정의된다**는 것이 큰 장점이다. 상속은 여러 상속 depth에 의해 보이지 않는 기능들이 많으나, 조합은 상관없이 해당 클래스에서 제공하는 모든 기능이 존재한다. 보이지 않으면 뭐 어떤가 싶지만, 상속 깊이가 깊어질수록 해당 기능이 한참 부모에 정의되어 있을 수도 있고, 어쩌면 중간 부모에서 재정의했을 수도 있다. 구현이 명시적이지 않다는 것이다.

하지만 조합은 위의 장점에 따른 단점도 존재한다. 단순 위임하는 기능들이 생긴다. `draw()` 같은 경우가 이에 해당한다. 위임하는 기능들이 점점 많아질수록 이런 불필요한 코드가 증가할 수 있다.

### 상속은 어렵다.

내 생각에는 **상속은 정말 어렵다.**

상속은 하나를 구현하면서도 부모클래스에 대한 생각을 떨쳐내기 어렵다. 또 부모에서 열린 기능이라면 자식에서 닫을 수도 없다. 자식 클래스는 부모에 계속 종속적이다.

이 종속성이 올바르지 않은 상속을 만든다. 예를 들어,

- `사람` 클래스는 밥을 먹을 수 있다.
- `간디` 클래스는 사람을 상속한다.
    - 근데 간디는 밥을 먹지 않는다. (사실과 다를 수 있음)
    - 따라서 간디는 메서드 재정의를 통해 해당 기능을 닫아야 한다. (예외를 던지는 방식)
- 최선을 다했지면 결국 LSP 원칙 위반이고, 사용하기 어려운 클래스 구조가 된다.

따라서 상속을 사용하기 위한 부모 클래스는 미래의 자식들에 대한 고민을 많이 하여 작성되어야 한다. 이것이 어려움을 만든다.

### 조합은 쉽다.

반면에 **조합은 아주 쉬운 편이다.**

기존 클래스를 사용하는 클래스에서 기존 클래스의 모든 기능을 사용하도록 강제하지 않는다. 입맛에 맞춰 가져다 쓰기만 하면 된다.

- `사람` 클래스는 밥을 먹을 수 있다.
- `간디` 클래스는 `사람` 클래스를 사용하며, 필요한 기능들을 가져다 쓴다.
    - 밥 먹는 기능은 안써도 된다.

또한 내가 느낀 조합의 유일한 단점은 코드 중복이 늘어난다는 것(메서드 포워딩) 인데, **나는 오히려 이 메서드 포워딩에 의한 코드 중복이 마음에 들었다.** 한 눈에 모든 기능을 볼 수 있다는 것이 명확했다.

또한 정 필요하면 롬복의 기능을 활용하여 중복 코드를 제거할 수도 있다.

> 결론적으로 나는 조합이 너무 좋다… 상속을 굳이 사용해야할 상황을 만나지 못했다. 장기적으로 더 고민하다가, 상속이 필요한 경우가 있으면 따로 회고하겠다!

# 장기 미션

---

장기 미션에서는 새로운 기술적인 깨달음보다, **우테코에서의 학습과 내 태도에 대해서 고민했다.**

## 좋은 코드, 안좋은 코드

**좋은 코드와 안좋은 코드는 존재할까? 그 경계는 무엇일까?**

나는 유연성이 낮은 코드가 안좋은 코드라고 생각했다. 과연 그럴까? 그러면 얼마나 유연해야 할까?

- 도메인에 따라 달라지는가?
    - 장기의 기물들은 확장될 수 있어야 할까? 몇백년동안 그대로인 게임에서 확장성을 챙기는게 무슨 소용인가
    - 곰곰히 생각해보면 유연성을 챙길 필요가 없는 경우가 다수다.
- 가독성에 따라 달라지는가?
    - 이 의견은 꽤 일리가 있다. 유연성이 없는 코드는 읽기 힘든 경우가 다수다.
    - 하지만 이것도 어느 수준 이상 챙기면 적당히 잘 읽힌다.
    - 그리고 너무 주관적이다. 누구는 1 클래스에 다 몰아 넣는게 낫다고 생각할 수도 있다.

이것 외에도 여러 고민을 했다. 그리고 **정답은 없다.** 라는 결론에 이르렀다.

그리고 어쩌면 미션 뿐만 아니라 실제 상황에서도 정답이 없을 수 있다고 생각하게 되었다. **내가 할 수 있는 것은 내가 원하는 만큼의 유연성과 가독성을 챙기는 것이다.** 유연성이 필요 없다고 생각하는가? 그렇게 하라.

우테코에서 학습하는 것은

- **어떤 요구사항을 읽고 필요한 세부 요구사항들을 짜는 것**
    - 편의점의 프로모션은 추후에 수정될 가능성이 높다. 유연하게 짜야 할 것이다.
    - 장기의 기물들은 추후에 수정될 가능성이 낮다. 유연하지 않아도 될 것이다. 하지만 중요한 도메인이니 가독성은 좋아야 한다.
- **미래의 어떤 세부 요구사항에도 대응할 수 있도록 수많은 경험을 쌓는 것**
    - 잘 읽히는 코드도, 최대한 빨리 짜는 코드도, 안정적인 코드도, 유연한 코드도 모두 짤 수 있어야 한다.
    - 그래야 내 선택지가 넓어질 수 있다.

위 2가지라고 생각하게 되었다.

레벨 2 부터는 이것저것 시도해보고 경험하고 내 선택지를 늘리려고 노력하게 될 것 같다.