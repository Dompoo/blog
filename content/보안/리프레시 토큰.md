- 근데 이러면 인증 토큰 탈취시(XSS) 악성 요청을 보낼 수 있다.
    - 따라서 인증 토큰의 유효기간을 짧게 잡는 것이 중요하다.
    - 하지만 이런 경우 자주 로그인해야 하기 때문에 불편하다.
- 또한 한번 발급 후에는 철회가 어렵다. (유효기간을 길게 설정하면 위험하다.)
- 이때 리프레시 토큰이 등장한다.

## 리프레시 토큰이란

- **짧은 수명의 인증 토큰을 재발급하기 위한 수단이다.**
- 로그인시 인증 토큰과 리프레시 토큰을 같이 지급한다.
    - 리프레시 토큰은 httpOnly 쿠키로 발급하여 XSS 공격을 방어해야 한다.
    - 서버는 리프레시 토큰 정보를 사용자 정보와 함께 저장해놓는다.
- 클라이언트는 인증 토큰으로 원하는 기능을 사용한다.
- 클라이언트는 재발급 API에 리프레시 토큰을 재출하여 인증토큰과 리프레시토큰을 받는다.
    - 로테이션을 사용하지 않으면
        - 새로운 인증 토큰
        - 기존 리프레시 토큰
    - 로테이션을 사용하면
        - 새로운 인증 토큰
        - 기존 리프레시 토큰 폐기
        - 새로운 리프레시 토큰
- 로그아웃시 / 인증 토큰이 탈취되었을 시 로테이션되었을 경우 기존 리프레시를 폐기한다. (저장소에서 제거)

## 리프레시 토큰 로테이션

- 리프레시 토큰에 로그아웃 기능과 보안 기능을 추가하기 위한 개념이다.
- 새로운 리프레시 토큰을 발급받았을 경우 기존 리프레시 토큰을 무효화하여 이전 리프레시 토큰을 통한 접근을 막는다.

## 리프레시 토큰 재사용 감지

- 기존 리프레시 토큰이 재사용된다면 보안적으로 위험한 상황일 수 있다.
- 기존 리프레시 토큰이 재사용되었을 때, 모든 리프레시 토큰 폐기 + 추가 인증 요구를 통하여 보안을 강화할 수 있다.

## 리프레시 토큰 DB 저장시 유의사항

- 리프레시 토큰 값을 DB에 그대로 저장하면 유출시 문제가 커질 수 있다.
- 따라서 해싱하여 저장해야 한다.
→ 근데 그러면 추후에 로테이션 로직에서 기존 리프레시 토큰을 찾지 못한다.
→ expire 검사 / revoke 검사 등을 수행할 수 없다.
- 따라서 리프레시 토큰 값을 해시하여 저장하고, id에 해당하는 무작위 값을 추가해주어야 한다.
→ 이것을 Jwt Token Id, jti 라고 부른다.

## 예시 코드

```java
@Transactional
public TokenResponse authenticateAndGetToken(String username, String password) {
  Member member = memberRepository.findByUsername(username).orElseThrow(() -> new UsernameNotFoundException(""));
  validatePasswordMatches(password, member);
  refreshTokenRepository.findByMemberId(member.getId()).forEach(RefreshToken::revoke);

  return issueNewToken(member.getId(), username);
}

private void validatePasswordMatches(String password, Member member) {
  if (!passwordEncoder.matches(password, member.getPassword())) {
    throw new BadCredentialsException("");
  }
}

@Transactional
public TokenResponse rotate(String refreshTokenValue) {
  String[] parts = refreshTokenValue.split("\\.", 2);
  if (parts.length != 2 || parts[0].isBlank() || parts[1].isBlank()) {
    throw new BadCredentialsException("malformed refresh token");
  }
  String jti = parts[0];
  String secret = parts[1];

  RefreshToken oldRefreshToken = refreshTokenRepository.findById(jti).orElseThrow(() -> new BadCredentialsException(""));
  Member member = memberRepository.findById(oldRefreshToken.getMemberId()).orElseThrow();
  validateNotExpired(oldRefreshToken);
  validateNotRevoked(oldRefreshToken);
  validateHashMatches(secret, oldRefreshToken.getEncodedValue());
  oldRefreshToken.revoke();

  return issueNewToken(member.getId(), member.getUsername());
}

private static void validateNotExpired(RefreshToken oldRefreshToken) {
  if (oldRefreshToken.isExpired()) {
    throw new CredentialsExpiredException("");
  }
}

private static void validateNotRevoked(RefreshToken oldRefreshToken) {
  if (oldRefreshToken.isRevoked()) {
    throw new BadCredentialsException("");
  }
}

private void validateHashMatches(String secret, String encodedValue) {
  if (!passwordEncoder.matches(secret, encodedValue)) {
    throw new BadCredentialsException("");
  }
}

private TokenResponse issueNewToken(Long memberId, String username) {
  String accessToken = tokenUtil.generateAccessToken(username);
  String rawRefreshToken = tokenUtil.genereteRefreshToken();

  RefreshToken refreshToken = new RefreshToken(memberId, passwordEncoder.encode(rawRefreshToken));
  refreshTokenRepository.save(refreshToken);

  String clientRefreshToken = refreshToken.getJti() + "." + rawRefreshToken;
  return new TokenResponse(accessToken, clientRefreshToken);
}
```